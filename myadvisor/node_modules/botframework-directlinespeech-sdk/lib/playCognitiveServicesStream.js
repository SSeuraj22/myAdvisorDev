"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = playCognitiveServicesStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _createMultiBufferingPlayer = _interopRequireDefault(require("./createMultiBufferingPlayer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Safari requires an audio buffer with a sample rate of 22050 Hz.
// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.
var MIN_SAMPLE_RATE = 44100; // The Speech SDK is hardcoded to chop packets to 4096 bytes.
// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).
// For simplicity, the multi-buffer player currently does not support progressive buffering.
// Progressive buffering allows queuing at any sample size and will be concatenated.
// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.
// For simplicity, data will be queued to two buffers.
// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.
// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.

var DEFAULT_BUFFER_SIZE = 4096;

function average(array) {
  return array.reduce(function (sum, value) {
    return sum + value;
  }, 0) / array.length;
}

function formatTypedBitArrayToFloatArray(audioData, maxValue) {
  var float32Data = new Float32Array(audioData.length);

  for (var i = 0; i < audioData.length; i++) {
    float32Data[i] = audioData[i] / maxValue;
  }

  return float32Data;
}

function formatAudioDataArrayBufferToFloatArray(_ref, arrayBuffer) {
  var bitsPerSample = _ref.bitsPerSample;

  switch (bitsPerSample) {
    case 8:
      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);

    case 16:
      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);

    case 32:
      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);

    default:
      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');
  }
}

function abortToReject(signal) {
  return new Promise(function (_, reject) {
    signal.onabort = function () {
      return reject(new Error('aborted'));
    };
  });
} // In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like "ABABABABAB".
// This function will take "ABABABABAB" and return an array ["AAAAA", "BBBBB"].


function deinterleave(channelInterleavedAudioData, _ref2) {
  var channels = _ref2.channels;
  var multiChannelArrayBuffer = new Array(channels);
  var frameSize = channelInterleavedAudioData.length / channels;

  for (var channel = 0; channel < channels; channel++) {
    var audioData = new Float32Array(frameSize);
    multiChannelArrayBuffer[channel] = audioData;

    for (var offset = 0; offset < frameSize; offset++) {
      audioData[offset] = channelInterleavedAudioData[offset * channels + channel];
    }
  }

  return multiChannelArrayBuffer;
} // This function upsamples the audio data via an integer multiplier.
// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.


function multiplySampleRate(source, sampleRateMultiplier) {
  if (sampleRateMultiplier === 1) {
    return source;
  }

  var lastValues = new Array(sampleRateMultiplier).fill(source[0]);
  var target = new Float32Array(source.length * sampleRateMultiplier);

  for (var sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {
    var value = source[sourceOffset];
    var targetOffset = sourceOffset * sampleRateMultiplier;

    for (var multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {
      lastValues.shift();
      lastValues.push(value);
      target[targetOffset + multiplierIndex] = average(lastValues);
    }
  }

  return target;
}

function playCognitiveServicesStream(_x, _x2) {
  return _playCognitiveServicesStream.apply(this, arguments);
}

function _playCognitiveServicesStream() {
  _playCognitiveServicesStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(audioContext, stream) {
    var _ref3,
        _ref3$signal,
        signal,
        queuedBufferSourceNodes,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref3 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref3$signal = _ref3.signal, signal = _ref3$signal === void 0 ? {} : _ref3$signal;

            if (audioContext) {
              _context2.next = 5;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');

          case 5:
            if (stream) {
              _context2.next = 9;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream must be specified.');

          case 9:
            if (stream.format) {
              _context2.next = 13;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing format.');

          case 13:
            if (!(typeof stream.read !== 'function')) {
              _context2.next = 15;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing read().');

          case 15:
            queuedBufferSourceNodes = [];
            _context2.prev = 16;
            return _context2.delegateYield( /*#__PURE__*/_regenerator.default.mark(function _callee() {
              var format, abortPromise, array, read, samplesPerSec, newSamplesPerSec, sampleRateMultiplier, player, chunk, maxChunks, interleavedArray, multiChannelArray, upsampledMultiChannelArray;
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      format = stream.format;
                      abortPromise = abortToReject(signal);
                      array = new Uint8Array(DEFAULT_BUFFER_SIZE);

                      read = function read() {
                        return Promise.race([// Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.
                        // eslint-disable-next-line no-empty-function
                        abortPromise.catch(function () {}), stream.read(array.buffer).then(function (numBytes) {
                          return numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined;
                        })]);
                      };

                      if (!signal.aborted) {
                        _context.next = 6;
                        break;
                      }

                      throw new Error('aborted');

                    case 6:
                      samplesPerSec = format.samplesPerSec; // TODO: [P0] #3692 Remove the following if-condition block when the underlying bugs are resolved.
                      //       There is a bug in Speech SDK 1.15.0 that returns 24kHz instead of 16kHz.
                      //       Even if we explicitly specify the output audio format to 16kHz, there is another bug that ignored it.
                      //       In short, DLSpeech service currently always streams in RIFF WAV format, instead of MP3.
                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/313
                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/314

                      if (format.requestAudioFormatString === 'audio-24khz-48kbitrate-mono-mp3') {
                        samplesPerSec = 16000;
                      }

                      newSamplesPerSec = samplesPerSec;
                      sampleRateMultiplier = 1; // Safari requires a minimum sample rate of 22100 Hz.
                      // A multiplier is calculated the the data meets the minimum sample rate.
                      // An integer-based multiplier to simplify our upsampler.
                      // For security, data will only be upsampled up to 96000 Hz.

                      while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {
                        sampleRateMultiplier++;
                        newSamplesPerSec = samplesPerSec * sampleRateMultiplier;
                      } // The third parameter is the sample size in bytes.
                      // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.
                      // The multi-buffering player is set up to handle 2048 samples per buffer.
                      // If the multiplier 3x, it will handle 6144 samples per buffer.


                      player = (0, _createMultiBufferingPlayer.default)(audioContext, _objectSpread(_objectSpread({}, format), {}, {
                        samplesPerSec: newSamplesPerSec
                      }), DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8) * sampleRateMultiplier); // For security, the maximum number of chunks handled will be 1000.

                      _context.next = 14;
                      return read();

                    case 14:
                      chunk = _context.sent;
                      maxChunks = 0;

                    case 16:
                      if (!(chunk && maxChunks < 1000 && !signal.aborted)) {
                        _context.next = 29;
                        break;
                      }

                      if (!signal.aborted) {
                        _context.next = 19;
                        break;
                      }

                      return _context.abrupt("break", 29);

                    case 19:
                      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as "ABABABABAB"
                      // And each sample (A/B) will be an 8 to 32-bit number.
                      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.
                      interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer); // Deinterleave data back into two array buffer, e.g. "AAAAA" and "BBBBB".

                      multiChannelArray = deinterleave(interleavedArray, format); // Upsample data if necessary. If the multiplier is 2x, "AAAAA" will be upsampled to "AAAAAAAAAA" (with anti-alias).

                      upsampledMultiChannelArray = multiChannelArray.map(function (array) {
                        return multiplySampleRate(array, sampleRateMultiplier);
                      }); // Queue to the buffering player.

                      player.push(upsampledMultiChannelArray);

                    case 23:
                      _context.next = 25;
                      return read();

                    case 25:
                      chunk = _context.sent;
                      maxChunks++;
                      _context.next = 16;
                      break;

                    case 29:
                      abortPromise.catch(function () {
                        return player.cancelAll();
                      });

                      if (!signal.aborted) {
                        _context.next = 32;
                        break;
                      }

                      throw new Error('aborted');

                    case 32:
                      _context.next = 34;
                      return Promise.race([abortPromise, player.flush()]);

                    case 34:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })(), "t0", 18);

          case 18:
            _context2.prev = 18;
            queuedBufferSourceNodes.forEach(function (node) {
              return node.stop();
            });
            return _context2.finish(18);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[16,, 18, 21]]);
  }));
  return _playCognitiveServicesStream.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wbGF5Q29nbml0aXZlU2VydmljZXNTdHJlYW0uanMiXSwibmFtZXMiOlsiTUlOX1NBTVBMRV9SQVRFIiwiREVGQVVMVF9CVUZGRVJfU0laRSIsImF2ZXJhZ2UiLCJhcnJheSIsInJlZHVjZSIsInN1bSIsInZhbHVlIiwibGVuZ3RoIiwiZm9ybWF0VHlwZWRCaXRBcnJheVRvRmxvYXRBcnJheSIsImF1ZGlvRGF0YSIsIm1heFZhbHVlIiwiZmxvYXQzMkRhdGEiLCJGbG9hdDMyQXJyYXkiLCJpIiwiZm9ybWF0QXVkaW9EYXRhQXJyYXlCdWZmZXJUb0Zsb2F0QXJyYXkiLCJhcnJheUJ1ZmZlciIsImJpdHNQZXJTYW1wbGUiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkVycm9yIiwiYWJvcnRUb1JlamVjdCIsInNpZ25hbCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwib25hYm9ydCIsImRlaW50ZXJsZWF2ZSIsImNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YSIsImNoYW5uZWxzIiwibXVsdGlDaGFubmVsQXJyYXlCdWZmZXIiLCJBcnJheSIsImZyYW1lU2l6ZSIsImNoYW5uZWwiLCJvZmZzZXQiLCJtdWx0aXBseVNhbXBsZVJhdGUiLCJzb3VyY2UiLCJzYW1wbGVSYXRlTXVsdGlwbGllciIsImxhc3RWYWx1ZXMiLCJmaWxsIiwidGFyZ2V0Iiwic291cmNlT2Zmc2V0IiwidGFyZ2V0T2Zmc2V0IiwibXVsdGlwbGllckluZGV4Iiwic2hpZnQiLCJwdXNoIiwicGxheUNvZ25pdGl2ZVNlcnZpY2VzU3RyZWFtIiwiYXVkaW9Db250ZXh0Iiwic3RyZWFtIiwiZm9ybWF0IiwicmVhZCIsInF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzIiwiYWJvcnRQcm9taXNlIiwiVWludDhBcnJheSIsInJhY2UiLCJjYXRjaCIsImJ1ZmZlciIsInRoZW4iLCJudW1CeXRlcyIsImJ5dGVMZW5ndGgiLCJzbGljZSIsInVuZGVmaW5lZCIsImFib3J0ZWQiLCJzYW1wbGVzUGVyU2VjIiwicmVxdWVzdEF1ZGlvRm9ybWF0U3RyaW5nIiwibmV3U2FtcGxlc1BlclNlYyIsInBsYXllciIsImNodW5rIiwibWF4Q2h1bmtzIiwiaW50ZXJsZWF2ZWRBcnJheSIsIm11bHRpQ2hhbm5lbEFycmF5IiwidXBzYW1wbGVkTXVsdGlDaGFubmVsQXJyYXkiLCJtYXAiLCJjYW5jZWxBbGwiLCJmbHVzaCIsImZvckVhY2giLCJub2RlIiwic3RvcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7Ozs7OztBQUVBO0FBQ0E7QUFDQSxJQUFNQSxlQUFlLEdBQUcsS0FBeEIsQyxDQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBQ0EsSUFBTUMsbUJBQW1CLEdBQUcsSUFBNUI7O0FBRUEsU0FBU0MsT0FBVCxDQUFpQkMsS0FBakIsRUFBd0I7QUFDdEIsU0FBT0EsS0FBSyxDQUFDQyxNQUFOLENBQWEsVUFBQ0MsR0FBRCxFQUFNQyxLQUFOO0FBQUEsV0FBZ0JELEdBQUcsR0FBR0MsS0FBdEI7QUFBQSxHQUFiLEVBQTBDLENBQTFDLElBQStDSCxLQUFLLENBQUNJLE1BQTVEO0FBQ0Q7O0FBRUQsU0FBU0MsK0JBQVQsQ0FBeUNDLFNBQXpDLEVBQW9EQyxRQUFwRCxFQUE4RDtBQUM1RCxNQUFNQyxXQUFXLEdBQUcsSUFBSUMsWUFBSixDQUFpQkgsU0FBUyxDQUFDRixNQUEzQixDQUFwQjs7QUFFQSxPQUFLLElBQUlNLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdKLFNBQVMsQ0FBQ0YsTUFBOUIsRUFBc0NNLENBQUMsRUFBdkMsRUFBMkM7QUFDekNGLElBQUFBLFdBQVcsQ0FBQ0UsQ0FBRCxDQUFYLEdBQWlCSixTQUFTLENBQUNJLENBQUQsQ0FBVCxHQUFlSCxRQUFoQztBQUNEOztBQUVELFNBQU9DLFdBQVA7QUFDRDs7QUFFRCxTQUFTRyxzQ0FBVCxPQUFtRUMsV0FBbkUsRUFBZ0Y7QUFBQSxNQUE5QkMsYUFBOEIsUUFBOUJBLGFB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QUFKLENBQVUsU0FBVixDQWpHRzs7QUFBQTtBQUFBO0FBQUEsNkJBb0dMRyxPQUFPLENBQUMrQixJQUFSLENBQWEsQ0FBQ0YsWUFBRCxFQUFlYyxNQUFNLENBQUNRLEtBQVAsRUFBZixDQUFiLENBcEdLOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFzR1h2QixZQUFBQSx1QkFBdUIsQ0FBQ3dCLE9BQXhCLENBQWdDLFVBQUFDLElBQUk7QUFBQSxxQkFBSUEsSUFBSSxDQUFDQyxJQUFMLEVBQUo7QUFBQSxhQUFwQztBQXRHVzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHIiwic291cmNlUm9vdCI6ImRpcmVjdGxpbmVzcGVlY2g6Ly8vIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IFtcImVycm9yXCIsIHsgXCJpZ25vcmVcIjogWzAsIDEsIDgsIDE2LCAzMiwgMTI4LCAxMDAwLCAxNjAwMCwgMzI3NjgsIDk2MDAwLCAyMTQ3NDgzNjQ4XSB9XSAqL1xuLyogZXNsaW50IG5vLWF3YWl0LWluLWxvb3A6IFwib2ZmXCIgKi9cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogXCJvZmZcIiAqL1xuXG5pbXBvcnQgY3JlYXRlTXVsdGlCdWZmZXJpbmdQbGF5ZXIgZnJvbSAnLi9jcmVhdGVNdWx0aUJ1ZmZlcmluZ1BsYXllcic7XG5cbi8vIFNhZmFyaSByZXF1aXJlcyBhbiBhdWRpbyBidWZmZXIgd2l0aCBhIHNhbXBsZSByYXRlIG9mIDIyMDUwIEh6LlxuLy8gVXNpbmcgYSBtaW5pbXVtIHNhbXBsZSByYXRlIG9mIDQ0MTAwIEh6IGFzIGFuIGV4YW1wbGUsIHRoZSBTcGVlY2ggU0RLJ3MgZGVmYXVsdCAxNjAwMCBIeiB3aWxsIGJlIHVwc2FtcGxlZCB0byA0ODAwMCBIei5cbmNvbnN0IE1JTl9TQU1QTEVfUkFURSA9IDQ0MTAwO1xuXG4vLyBUaGUgU3BlZWNoIFNESyBpcyBoYXJkY29kZWQgdG8gY2hvcCBwYWNrZXRzIHRvIDQwOTYgYnl0ZXMuXG4vLyBXZWIgQ2hhdCdzIG11bHRpLWJ1ZmZlcmluZyBwbGF5ZXIgaXMgc2V0IHVwIHdpdGggMyBidWZmZXJzOyBlYWNoIGlzIDQwOTYgYnl0ZXMgKDIwNDggMTYtYml0IHNhbXBsZXMpLlxuLy8gRm9yIHNpbXBsaWNpdHksIHRoZSBtdWx0aS1idWZmZXIgcGxheWVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHByb2dyZXNzaXZlIGJ1ZmZlcmluZy5cblxuLy8gUHJvZ3Jlc3NpdmUgYnVmZmVyaW5nIGFsbG93cyBxdWV1aW5nIGF0IGFueSBzYW1wbGUgc2l6ZSBhbmQgd2lsbCBiZSBjb25jYXRlbmF0ZWQuXG4vLyBJZiAxMDAwIHNhbXBsZXMgYXJlIHF1ZXVlZCwgdGhlbiAxMDQ4IHNhbXBsZXMgYXJlIHF1ZXVlZCwgdGhleSB3aWxsIGJlIGNvbmNhdGVuYXRlZCBpbnRvIGEgc2luZ2xlIGJ1ZmZlciBvZiBzaXplIDIwNDguXG5cbi8vIEZvciBzaW1wbGljaXR5LCBkYXRhIHdpbGwgYmUgcXVldWVkIHRvIHR3byBidWZmZXJzLlxuLy8gVGhlIGZpcnN0IGJ1ZmZlciBpcyAxMDAwIHNhbXBsZXMgZm9sbG93ZWQgYnkgMTA0OCB6ZXJvZXMsIGFuZCB0aGUgc2Vjb25kIGJ1ZmZlciBpcyAxMDQ4IHNhbXBsZXMgZm9sbG93ZWQgYnkgMTAwMCB6ZXJvZXMuXG5cbi8vIFRoZXJlIGlzIG5vIHBsYW4gdG8gc3VwcG9ydCBwcm9ncmVzc2l2ZSBidWZmZXJpbmcgdW50aWwgdGhlIFNwZWVjaCBTREsgY2hvcHMgZGF0YSBhdCBkeW5hbWljIHNpemUuXG5jb25zdCBERUZBVUxUX0JVRkZFUl9TSVpFID0gNDA5NjtcblxuZnVuY3Rpb24gYXZlcmFnZShhcnJheSkge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCkgLyBhcnJheS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkoYXVkaW9EYXRhLCBtYXhWYWx1ZSkge1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYXVkaW9EYXRhLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBmbG9hdDMyRGF0YVtpXSA9IGF1ZGlvRGF0YVtpXSAvIG1heFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGZsb2F0MzJEYXRhO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBdWRpb0RhdGFBcnJheUJ1ZmZlclRvRmxvYXRBcnJheSh7IGJpdHNQZXJTYW1wbGUgfSwgYXJyYXlCdWZmZXIpIHtcbiAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDhBcnJheShhcnJheUJ1ZmZlciksIDEyOCk7XG5cbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDE2QXJyYXkoYXJyYXlCdWZmZXIpLCAzMjc2OCk7XG5cbiAgICBjYXNlIDMyOlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDMyQXJyYXkoYXJyYXlCdWZmZXIpLCAyMTQ3NDgzNjQ4KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgV0FWRV9GT1JNQVRfUENNICg4LzE2LzMyIGJwcykgZm9ybWF0IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRvUmVqZWN0KHNpZ25hbCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHNpZ25hbC5vbmFib3J0ID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignYWJvcnRlZCcpKTtcbiAgfSk7XG59XG5cbi8vIEluIGEgMiBjaGFubmVsIGF1ZGlvIChlLmcuIEEvQiksIHRoZSBkYXRhIGFycml2ZXMgYXMgaW50ZXJsZWF2ZWQsIGxpa2UgXCJBQkFCQUJBQkFCXCIuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgdGFrZSBcIkFCQUJBQkFCQUJcIiBhbmQgcmV0dXJuIGFuIGFycmF5IFtcIkFBQUFBXCIsIFwiQkJCQkJcIl0uXG5mdW5jdGlvbiBkZWludGVybGVhdmUoY2hhbm5lbEludGVybGVhdmVkQXVkaW9EYXRhLCB7IGNoYW5uZWxzIH0pIHtcbiAgY29uc3QgbXVsdGlDaGFubmVsQXJyYXlCdWZmZXIgPSBuZXcgQXJyYXkoY2hhbm5lbHMpO1xuICBjb25zdCBmcmFtZVNpemUgPSBjaGFubmVsSW50ZXJsZWF2ZWRBdWRpb0RhdGEubGVuZ3RoIC8gY2hhbm5lbHM7XG5cbiAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBjaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgY29uc3QgYXVkaW9EYXRhID0gbmV3IEZsb2F0MzJBcnJheShmcmFtZVNpemUpO1xuXG4gICAgbXVsdGlDaGFubmVsQXJyYXlCdWZmZXJbY2hhbm5lbF0gPSBhdWRpb0RhdGE7XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBmcmFtZVNpemU7IG9mZnNldCsrKSB7XG4gICAgICBhdWRpb0RhdGFbb2Zmc2V0XSA9IGNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YVtvZmZzZXQgKiBjaGFubmVscyArIGNoYW5uZWxdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtdWx0aUNoYW5uZWxBcnJheUJ1ZmZlcjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB1cHNhbXBsZXMgdGhlIGF1ZGlvIGRhdGEgdmlhIGFuIGludGVnZXIgbXVsdGlwbGllci5cbi8vIFdlYiBDaGF0IHVzZXMgc2ltcGxlIGFudGktYWxpYXNpbmcuIEZvciBzaW1wbGljaXR5LCB0aGUgYW50aS1hbGlhc2luZyBkb2VzIG5vdCByb2xsIG92ZXIgdG8gbmV4dCBidWZmZXIuXG5mdW5jdGlvbiBtdWx0aXBseVNhbXBsZVJhdGUoc291cmNlLCBzYW1wbGVSYXRlTXVsdGlwbGllcikge1xuICBpZiAoc2FtcGxlUmF0ZU11bHRpcGxpZXIgPT09IDEpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgY29uc3QgbGFzdFZhbHVlcyA9IG5ldyBBcnJheShzYW1wbGVSYXRlTXVsdGlwbGllcikuZmlsbChzb3VyY2VbMF0pO1xuICBjb25zdCB0YXJnZXQgPSBuZXcgRmxvYXQzMkFycmF5KHNvdXJjZS5sZW5ndGggKiBzYW1wbGVSYXRlTXVsdGlwbGllcik7XG5cbiAgZm9yIChsZXQgc291cmNlT2Zmc2V0ID0gMDsgc291cmNlT2Zmc2V0IDwgc291cmNlLmxlbmd0aDsgc291cmNlT2Zmc2V0KyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IHNvdXJjZU9mZnNldCAqIHNhbXBsZVJhdGVNdWx0aXBsaWVyO1xuXG4gICAgZm9yIChsZXQgbXVsdGlwbGllckluZGV4ID0gMDsgbXVsdGlwbGllckluZGV4IDwgc2FtcGxlUmF0ZU11bHRpcGxpZXI7IG11bHRpcGxpZXJJbmRleCsrKSB7XG4gICAgICBsYXN0VmFsdWVzLnNoaWZ0KCk7XG4gICAgICBsYXN0VmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgdGFyZ2V0W3RhcmdldE9mZnNldCArIG11bHRpcGxpZXJJbmRleF0gPSBhdmVyYWdlKGxhc3RWYWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsYXlDb2duaXRpdmVTZXJ2aWNlc1N0cmVhbShhdWRpb0NvbnRleHQsIHN0cmVhbSwgeyBzaWduYWwgPSB7fSB9ID0ge30pIHtcbiAgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogYXVkaW9Db250ZXh0IG11c3QgYmUgc3BlY2lmaWVkLicpO1xuICB9IGVsc2UgaWYgKCFzdHJlYW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogc3RyZWFtIG11c3QgYmUgc3BlY2lmaWVkLicpO1xuICB9IGVsc2UgaWYgKCFzdHJlYW0uZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RmcmFtZXdvcmstZGlyZWN0bGluZXNwZWVjaC1zZGs6IHN0cmVhbSBpcyBtaXNzaW5nIGZvcm1hdC4nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtLnJlYWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogc3RyZWFtIGlzIG1pc3NpbmcgcmVhZCgpLicpO1xuICB9XG5cbiAgY29uc3QgcXVldWVkQnVmZmVyU291cmNlTm9kZXMgPSBbXTtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgZm9ybWF0IH0gPSBzdHJlYW07XG4gICAgY29uc3QgYWJvcnRQcm9taXNlID0gYWJvcnRUb1JlamVjdChzaWduYWwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoREVGQVVMVF9CVUZGRVJfU0laRSk7XG5cbiAgICBjb25zdCByZWFkID0gKCkgPT5cbiAgICAgIFByb21pc2UucmFjZShbXG4gICAgICAgIC8vIEFib3J0IHdpbGwgZ3JhY2VmdWxseSBlbmQgdGhlIHF1ZXVlLiBXZSB3aWxsIGNoZWNrIHNpZ25hbC5hYm9ydGVkIGxhdGVyIHRvIHRocm93IGFib3J0IGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG4gICAgICAgIGFib3J0UHJvbWlzZS5jYXRjaCgoKSA9PiB7fSksXG4gICAgICAgIHN0cmVhbVxuICAgICAgICAgIC5yZWFkKGFycmF5LmJ1ZmZlcilcbiAgICAgICAgICAudGhlbihudW1CeXRlcyA9PiAobnVtQnl0ZXMgPT09IGFycmF5LmJ5dGVMZW5ndGggPyBhcnJheSA6IG51bUJ5dGVzID8gYXJyYXkuc2xpY2UoMCwgbnVtQnl0ZXMpIDogdW5kZWZpbmVkKSlcbiAgICAgIF0pO1xuXG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fib3J0ZWQnKTtcbiAgICB9XG5cbiAgICBsZXQgeyBzYW1wbGVzUGVyU2VjIH0gPSBmb3JtYXQ7XG5cbiAgICAvLyBUT0RPOiBbUDBdICMzNjkyIFJlbW92ZSB0aGUgZm9sbG93aW5nIGlmLWNvbmRpdGlvbiBibG9jayB3aGVuIHRoZSB1bmRlcmx5aW5nIGJ1Z3MgYXJlIHJlc29sdmVkLlxuICAgIC8vICAgICAgIFRoZXJlIGlzIGEgYnVnIGluIFNwZWVjaCBTREsgMS4xNS4wIHRoYXQgcmV0dXJucyAyNGtIeiBpbnN0ZWFkIG9mIDE2a0h6LlxuICAgIC8vICAgICAgIEV2ZW4gaWYgd2UgZXhwbGljaXRseSBzcGVjaWZ5IHRoZSBvdXRwdXQgYXVkaW8gZm9ybWF0IHRvIDE2a0h6LCB0aGVyZSBpcyBhbm90aGVyIGJ1ZyB0aGF0IGlnbm9yZWQgaXQuXG4gICAgLy8gICAgICAgSW4gc2hvcnQsIERMU3BlZWNoIHNlcnZpY2UgY3VycmVudGx5IGFsd2F5cyBzdHJlYW1zIGluIFJJRkYgV0FWIGZvcm1hdCwgaW5zdGVhZCBvZiBNUDMuXG4gICAgLy8gICAgICAgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9jb2duaXRpdmUtc2VydmljZXMtc3BlZWNoLXNkay1qcy9pc3N1ZXMvMzEzXG4gICAgLy8gICAgICAgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9jb2duaXRpdmUtc2VydmljZXMtc3BlZWNoLXNkay1qcy9pc3N1ZXMvMzE0XG4gICAgaWYgKGZvcm1hdC5yZXF1ZXN0QXVkaW9Gb3JtYXRTdHJpbmcgPT09ICdhdWRpby0yNGtoei00OGtiaXRyYXRlLW1vbm8tbXAzJykge1xuICAgICAgc2FtcGxlc1BlclNlYyA9IDE2MDAwO1xuICAgIH1cblxuICAgIGxldCBuZXdTYW1wbGVzUGVyU2VjID0gc2FtcGxlc1BlclNlYztcbiAgICBsZXQgc2FtcGxlUmF0ZU11bHRpcGxpZXIgPSAxO1xuXG4gICAgLy8gU2FmYXJpIHJlcXVpcmVzIGEgbWluaW11bSBzYW1wbGUgcmF0ZSBvZiAyMjEwMCBIei5cbiAgICAvLyBBIG11bHRpcGxpZXIgaXMgY2FsY3VsYXRlZCB0aGUgdGhlIGRhdGEgbWVldHMgdGhlIG1pbmltdW0gc2FtcGxlIHJhdGUuXG4gICAgLy8gQW4gaW50ZWdlci1iYXNlZCBtdWx0aXBsaWVyIHRvIHNpbXBsaWZ5IG91ciB1cHNhbXBsZXIuXG4gICAgLy8gRm9yIHNlY3VyaXR5LCBkYXRhIHdpbGwgb25seSBiZSB1cHNhbXBsZWQgdXAgdG8gOTYwMDAgSHouXG4gICAgd2hpbGUgKG5ld1NhbXBsZXNQZXJTZWMgPCBNSU5fU0FNUExFX1JBVEUgJiYgbmV3U2FtcGxlc1BlclNlYyA8IDk2MDAwKSB7XG4gICAgICBzYW1wbGVSYXRlTXVsdGlwbGllcisrO1xuICAgICAgbmV3U2FtcGxlc1BlclNlYyA9IHNhbXBsZXNQZXJTZWMgKiBzYW1wbGVSYXRlTXVsdGlwbGllcjtcbiAgICB9XG5cbiAgICAvLyBUaGUgdGhpcmQgcGFyYW1ldGVyIGlzIHRoZSBzYW1wbGUgc2l6ZSBpbiBieXRlcy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgdGhlIFNwZWVjaCBTREsgc2VuZHMgV2ViIENoYXQgNDA5NiBieXRlcyBvZiAxNi1iaXQgc2FtcGxlcywgdGhlcmUgd2lsbCBiZSAyMDQ4IHNhbXBsZXMgcGVyIGNoYW5uZWwuXG4gICAgLy8gVGhlIG11bHRpLWJ1ZmZlcmluZyBwbGF5ZXIgaXMgc2V0IHVwIHRvIGhhbmRsZSAyMDQ4IHNhbXBsZXMgcGVyIGJ1ZmZlci5cbiAgICAvLyBJZiB0aGUgbXVsdGlwbGllciAzeCwgaXQgd2lsbCBoYW5kbGUgNjE0NCBzYW1wbGVzIHBlciBidWZmZXIuXG4gICAgY29uc3QgcGxheWVyID0gY3JlYXRlTXVsdGlCdWZmZXJpbmdQbGF5ZXIoXG4gICAgICBhdWRpb0NvbnRleHQsXG4gICAgICB7IC4uLmZvcm1hdCwgc2FtcGxlc1BlclNlYzogbmV3U2FtcGxlc1BlclNlYyB9LFxuICAgICAgKERFRkFVTFRfQlVGRkVSX1NJWkUgLyAoZm9ybWF0LmJpdHNQZXJTYW1wbGUgLyA4KSkgKiBzYW1wbGVSYXRlTXVsdGlwbGllclxuICAgICk7XG5cbiAgICAvLyBGb3Igc2VjdXJpdHksIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjaHVua3MgaGFuZGxlZCB3aWxsIGJlIDEwMDAuXG4gICAgZm9yIChcbiAgICAgIGxldCBjaHVuayA9IGF3YWl0IHJlYWQoKSwgbWF4Q2h1bmtzID0gMDtcbiAgICAgIGNodW5rICYmIG1heENodW5rcyA8IDEwMDAgJiYgIXNpZ25hbC5hYm9ydGVkO1xuICAgICAgY2h1bmsgPSBhd2FpdCByZWFkKCksIG1heENodW5rcysrXG4gICAgKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIERhdGEgcmVjZWl2ZWQgZnJvbSBTcGVlY2ggU0RLIGlzIGludGVybGVhdmVkOyAyIGNoYW5uZWxzIChlLmcuIEEgYW5kIEIpIHdpbGwgYmUgc2VudCBhcyBcIkFCQUJBQkFCQUJcIlxuICAgICAgLy8gQW5kIGVhY2ggc2FtcGxlIChBL0IpIHdpbGwgYmUgYW4gOCB0byAzMi1iaXQgbnVtYmVyLlxuXG4gICAgICAvLyBDb252ZXJ0IHRoZSA4IC0gMzItYml0IG51bWJlciBpbnRvIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBhcyByZXF1aXJlZCBieSBXZWIgQXVkaW8gQVBJLlxuICAgICAgY29uc3QgaW50ZXJsZWF2ZWRBcnJheSA9IGZvcm1hdEF1ZGlvRGF0YUFycmF5QnVmZmVyVG9GbG9hdEFycmF5KGZvcm1hdCwgY2h1bmsuYnVmZmVyKTtcblxuICAgICAgLy8gRGVpbnRlcmxlYXZlIGRhdGEgYmFjayBpbnRvIHR3byBhcnJheSBidWZmZXIsIGUuZy4gXCJBQUFBQVwiIGFuZCBcIkJCQkJCXCIuXG4gICAgICBjb25zdCBtdWx0aUNoYW5uZWxBcnJheSA9IGRlaW50ZXJsZWF2ZShpbnRlcmxlYXZlZEFycmF5LCBmb3JtYXQpO1xuXG4gICAgICAvLyBVcHNhbXBsZSBkYXRhIGlmIG5lY2Vzc2FyeS4gSWYgdGhlIG11bHRpcGxpZXIgaXMgMngsIFwiQUFBQUFcIiB3aWxsIGJlIHVwc2FtcGxlZCB0byBcIkFBQUFBQUFBQUFcIiAod2l0aCBhbnRpLWFsaWFzKS5cbiAgICAgIGNvbnN0IHVwc2FtcGxlZE11bHRpQ2hhbm5lbEFycmF5ID0gbXVsdGlDaGFubmVsQXJyYXkubWFwKGFycmF5ID0+XG4gICAgICAgIG11bHRpcGx5U2FtcGxlUmF0ZShhcnJheSwgc2FtcGxlUmF0ZU11bHRpcGxpZXIpXG4gICAgICApO1xuXG4gICAgICAvLyBRdWV1ZSB0byB0aGUgYnVmZmVyaW5nIHBsYXllci5cbiAgICAgIHBsYXllci5wdXNoKHVwc2FtcGxlZE11bHRpQ2hhbm5lbEFycmF5KTtcbiAgICB9XG5cbiAgICBhYm9ydFByb21pc2UuY2F0Y2goKCkgPT4gcGxheWVyLmNhbmNlbEFsbCgpKTtcblxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFthYm9ydFByb21pc2UsIHBsYXllci5mbHVzaCgpXSk7XG4gIH0gZmluYWxseSB7XG4gICAgcXVldWVkQnVmZmVyU291cmNlTm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUuc3RvcCgpKTtcbiAgfVxufVxuIl19
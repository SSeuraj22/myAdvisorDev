{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useAcknowledgedActivity;\n\nvar _botframeworkWebchatApi = require(\"botframework-webchat-api\");\n\nvar _react = require(\"react\");\n\nvar _reactScrollToBottom = require(\"react-scroll-to-bottom\");\n\nvar _findLastIndex = _interopRequireDefault(require(\"../../Utils/findLastIndex\"));\n\nvar _getActivityUniqueId = _interopRequireDefault(require(\"../../Utils/getActivityUniqueId\"));\n\nvar _useChanged = _interopRequireDefault(require(\"./useChanged\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar useActivities = _botframeworkWebchatApi.hooks.useActivities; // Acknowledged means either:\n// 1. The user sent a message\n//    - We don't need a condition here. When Web Chat sends the user's message, it will scroll to bottom, and it will trigger condition 2 below.\n// 2. The user scroll to the bottom of the transcript, from a non-bottom scroll position\n//    - If the transcript is already at the bottom, the user needs to scroll up and then go back down\n//    - What happens if we are relaxing \"scrolled from a non-bottom scroll position\":\n//      1. The condition will become solely \"at the bottom of the transcript\"\n//      2. Auto-scroll will always scroll the transcript to the bottom\n//      3. Web Chat will always acknowledge all activities as it is at the bottom\n//      4. Acknowledge flag become useless\n//      5. Therefore, even the developer set \"pause after 3 activities\", if activities are coming in at a slow pace (not batched in a single render)\n//         Web Chat will keep scrolling and not snapped/paused\n// Note: When Web Chat is loaded, there are no activities acknowledged. We need to assume all arriving activities are acknowledged until end-user sends their first activity.\n//       Activities loaded initially could be from conversation history. Without assuming acknowledgement, Web Chat will not scroll initially (as everything is not acknowledged).\n//       It would be better if the chat adapter should let Web Chat know if the activity is loaded from history or not.\n// TODO: [P2] #3670 Move the \"conversation history acknowledgement\" logic mentioned above to polyfill of chat adapters.\n//       1. Chat adapter should send \"acknowledged\" as part of \"channelData\"\n//       2. If \"acknowledged\" is \"undefined\", we set it to:\n//          a. true, if there are no egress activities yet\n//          b. Otherwise, false\n\nfunction useAcknowledgedActivity() {\n  var _useActivities = useActivities(),\n      _useActivities2 = _slicedToArray(_useActivities, 1),\n      activities = _useActivities2[0];\n\n  var _useSticky = (0, _reactScrollToBottom.useSticky)(),\n      _useSticky2 = _slicedToArray(_useSticky, 1),\n      sticky = _useSticky2[0];\n\n  var lastStickyActivityIDRef = (0, _react.useRef)();\n  var stickyChanged = (0, _useChanged.default)(sticky);\n  var stickyChangedToSticky = stickyChanged && sticky;\n  var lastStickyActivityID = (0, _react.useMemo)(function () {\n    if (stickyChangedToSticky) {\n      lastStickyActivityIDRef.current = (0, _getActivityUniqueId.default)(activities[activities.length - 1] || {});\n    }\n\n    return lastStickyActivityIDRef.current;\n  }, [activities, lastStickyActivityIDRef, stickyChangedToSticky]);\n  return (0, _react.useMemo)(function () {\n    var lastStickyActivityIndex = activities.findIndex(function (activity) {\n      return (0, _getActivityUniqueId.default)(activity) === lastStickyActivityID;\n    });\n    var lastEgressActivityIndex = (0, _findLastIndex.default)(activities, function (_ref) {\n      var _ref$from = _ref.from;\n      _ref$from = _ref$from === void 0 ? {} : _ref$from;\n      var role = _ref$from.role;\n      return role === 'user';\n    }); // As described above, if no activities were acknowledged through egress activity, we will assume everything is acknowledged.\n\n    var lastAcknowledgedActivityIndex = !~lastEgressActivityIndex ? activities.length - 1 : Math.max(lastStickyActivityIndex, lastEgressActivityIndex);\n    var lastAcknowledgedActivity = activities[lastAcknowledgedActivityIndex];\n    return [lastAcknowledgedActivity];\n  }, [activities, lastStickyActivityID]);\n}","map":{"version":3,"sources":["../../../src/hooks/internal/useAcknowledgedActivity.js"],"names":["useActivities","hooks","activities","sticky","lastStickyActivityIDRef","stickyChanged","stickyChangedToSticky","lastStickyActivityID","lastStickyActivityIndex","lastEgressActivityIndex","role","lastAcknowledgedActivityIndex","Math","lastAcknowledgedActivity"],"mappings":";;;;;;;AAAA,IAAA,uBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEA,IAAA,cAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,2BAAA,CAAA,CAAA;;AACA,IAAA,oBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,iCAAA,CAAA,CAAA;;AACA,IAAA,WAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAEQA,a,GAAkBC,uBAAAA,CAAAA,KAAAA,CAAlBD,a,EAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACe,SAAA,uBAAA,GAAmC;AAAA,MAAA,cAAA,GAC3BA,aAD2B,EAAA;AAAA,MAAA,eAAA,GAAA,cAAA,CAAA,cAAA,EAAA,CAAA,CAAA;AAAA,MACzCE,UADyC,GAAA,eAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,UAAA,GAE/B,CAAA,GAAA,oBAAA,CAF+B,SAE/B,GAF+B;AAAA,MAAA,WAAA,GAAA,cAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAA,MAEzCC,MAFyC,GAAA,WAAA,CAAA,CAAA,CAAA;;AAGhD,MAAMC,uBAAuB,GAAG,CAAA,GAAA,MAAA,CAAhC,MAAgC,GAAhC;AAEA,MAAMC,aAAa,GAAG,CAAA,GAAA,WAAA,CAAA,OAAA,EAAtB,MAAsB,CAAtB;AACA,MAAMC,qBAAqB,GAAGD,aAAa,IAA3C,MAAA;AAEA,MAAME,oBAAoB,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EAAQ,YAAM;AACzC,QAAA,qBAAA,EAA2B;AACzBH,MAAAA,uBAAuB,CAAvBA,OAAAA,GAAkC,CAAA,GAAA,oBAAA,CAAA,OAAA,EAAoBF,UAAU,CAACA,UAAU,CAAVA,MAAAA,GAAXA,CAAU,CAAVA,IAAtDE,EAAkC,CAAlCA;AACD;;AAED,WAAOA,uBAAuB,CAA9B,OAAA;AAL2B,GAAA,EAM1B,CAAA,UAAA,EAAA,uBAAA,EANH,qBAMG,CAN0B,CAA7B;AAQA,SAAO,CAAA,GAAA,MAAA,CAAA,OAAA,EAAQ,YAAM;AACnB,QAAMI,uBAAuB,GAAG,UAAU,CAAV,SAAA,CAC9B,UAAA,QAAA,EAAQ;AAAA,aAAI,CAAA,GAAA,oBAAA,CAAA,OAAA,EAAA,QAAA,MAAJ,oBAAA;AADV,KAAgC,CAAhC;AAIA,QAAMC,uBAAuB,GAAG,CAAA,GAAA,cAAA,CAAA,OAAA,EAAA,UAAA,EAA0B,UAAA,IAAA,EAAA;AAAA,UAAA,SAAA,GAAA,IAAA,CAAA,IAAA;AAAA,MAAA,SAAA,GAAA,SAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,SAAA;AAAA,UAAWC,IAAX,GAAA,SAAA,CAAA,IAAA;AAAA,aAA6BA,IAAI,KAAjC,MAAA;AALvC,KAKa,CAAhC,CALmB,CAOnB;;AACA,QAAMC,6BAA6B,GAAG,CAAC,CAAD,uBAAA,GAClCT,UAAU,CAAVA,MAAAA,GADkC,CAAA,GAElCU,IAAI,CAAJA,GAAAA,CAAAA,uBAAAA,EAFJ,uBAEIA,CAFJ;AAIA,QAAMC,wBAAwB,GAAGX,UAAU,CAA3C,6BAA2C,CAA3C;AAEA,WAAO,CAAP,wBAAO,CAAP;AAdK,GAAA,EAeJ,CAAA,UAAA,EAfH,oBAeG,CAfI,CAAP;AAgBD","sourcesContent":["import { hooks } from 'botframework-webchat-api';\nimport { useMemo, useRef } from 'react';\nimport { useSticky } from 'react-scroll-to-bottom';\n\nimport findLastIndex from '../../Utils/findLastIndex';\nimport getActivityUniqueId from '../../Utils/getActivityUniqueId';\nimport useChanged from './useChanged';\n\nconst { useActivities } = hooks;\n\n// Acknowledged means either:\n// 1. The user sent a message\n//    - We don't need a condition here. When Web Chat sends the user's message, it will scroll to bottom, and it will trigger condition 2 below.\n// 2. The user scroll to the bottom of the transcript, from a non-bottom scroll position\n//    - If the transcript is already at the bottom, the user needs to scroll up and then go back down\n//    - What happens if we are relaxing \"scrolled from a non-bottom scroll position\":\n//      1. The condition will become solely \"at the bottom of the transcript\"\n//      2. Auto-scroll will always scroll the transcript to the bottom\n//      3. Web Chat will always acknowledge all activities as it is at the bottom\n//      4. Acknowledge flag become useless\n//      5. Therefore, even the developer set \"pause after 3 activities\", if activities are coming in at a slow pace (not batched in a single render)\n//         Web Chat will keep scrolling and not snapped/paused\n\n// Note: When Web Chat is loaded, there are no activities acknowledged. We need to assume all arriving activities are acknowledged until end-user sends their first activity.\n//       Activities loaded initially could be from conversation history. Without assuming acknowledgement, Web Chat will not scroll initially (as everything is not acknowledged).\n//       It would be better if the chat adapter should let Web Chat know if the activity is loaded from history or not.\n\n// TODO: [P2] #3670 Move the \"conversation history acknowledgement\" logic mentioned above to polyfill of chat adapters.\n//       1. Chat adapter should send \"acknowledged\" as part of \"channelData\"\n//       2. If \"acknowledged\" is \"undefined\", we set it to:\n//          a. true, if there are no egress activities yet\n//          b. Otherwise, false\nexport default function useAcknowledgedActivity() {\n  const [activities] = useActivities();\n  const [sticky] = useSticky();\n  const lastStickyActivityIDRef = useRef();\n\n  const stickyChanged = useChanged(sticky);\n  const stickyChangedToSticky = stickyChanged && sticky;\n\n  const lastStickyActivityID = useMemo(() => {\n    if (stickyChangedToSticky) {\n      lastStickyActivityIDRef.current = getActivityUniqueId(activities[activities.length - 1] || {});\n    }\n\n    return lastStickyActivityIDRef.current;\n  }, [activities, lastStickyActivityIDRef, stickyChangedToSticky]);\n\n  return useMemo(() => {\n    const lastStickyActivityIndex = activities.findIndex(\n      activity => getActivityUniqueId(activity) === lastStickyActivityID\n    );\n\n    const lastEgressActivityIndex = findLastIndex(activities, ({ from: { role } = {} }) => role === 'user');\n\n    // As described above, if no activities were acknowledged through egress activity, we will assume everything is acknowledged.\n    const lastAcknowledgedActivityIndex = !~lastEgressActivityIndex\n      ? activities.length - 1\n      : Math.max(lastStickyActivityIndex, lastEgressActivityIndex);\n\n    const lastAcknowledgedActivity = activities[lastAcknowledgedActivityIndex];\n\n    return [lastAcknowledgedActivity];\n  }, [activities, lastStickyActivityID]);\n}\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}
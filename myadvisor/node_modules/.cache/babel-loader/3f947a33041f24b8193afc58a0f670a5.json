{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { connectivity, type } from \"../common.speech/Exports\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource } from \"../common/Exports\";\nimport { AudioStreamFormat } from \"../sdk/Audio/AudioStreamFormat\";\nexport class FileAudioSource {\n  constructor(file, audioSourceId) {\n    this.privStreams = {};\n    this.privHeaderEnd = 44;\n\n    this.turnOn = () => {\n      if (typeof FileReader === \"undefined\") {\n        const errorMsg = \"Browser does not support FileReader.\";\n        this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // initialization error - no streamid at this point\n\n        return Promise.reject(errorMsg);\n      } else if (this.privFile.name.lastIndexOf(\".wav\") !== this.privFile.name.length - 4) {\n        const errorMsg = this.privFile.name + \" is not supported. Only WAVE files are allowed at the moment.\";\n        this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n        return Promise.reject(errorMsg);\n      }\n\n      this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n\n      this.onEvent(new AudioSourceReadyEvent(this.privId));\n      return;\n    };\n\n    this.id = () => {\n      return this.privId;\n    };\n\n    this.attach = audioNodeId => __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      const stream = yield this.upload(audioNodeId);\n      this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return Promise.resolve({\n        detach: () => __awaiter(this, void 0, void 0, function* () {\n          stream.readEnded();\n          delete this.privStreams[audioNodeId];\n          this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          yield this.turnOff();\n        }),\n        id: () => {\n          return audioNodeId;\n        },\n        read: () => {\n          return stream.read();\n        }\n      });\n    });\n\n    this.detach = audioNodeId => {\n      if (audioNodeId && this.privStreams[audioNodeId]) {\n        this.privStreams[audioNodeId].close();\n        delete this.privStreams[audioNodeId];\n        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n      }\n    };\n\n    this.turnOff = () => {\n      for (const streamId in this.privStreams) {\n        if (streamId) {\n          const stream = this.privStreams[streamId];\n\n          if (stream && !stream.isClosed) {\n            stream.close();\n          }\n        }\n      }\n\n      this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n\n      return Promise.resolve();\n    };\n\n    this.onEvent = event => {\n      this.privEvents.onEvent(event);\n      Events.instance.onEvent(event);\n    };\n\n    this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n    this.privEvents = new EventSource();\n    this.privFile = file; // Read the header.\n\n    this.privAudioFormatPromise = this.readHeader();\n  }\n\n  get format() {\n    return this.privAudioFormatPromise;\n  }\n\n  get blob() {\n    return Promise.resolve(this.privFile);\n  }\n\n  get events() {\n    return this.privEvents;\n  }\n\n  get deviceInfo() {\n    return this.privAudioFormatPromise.then(result => {\n      return Promise.resolve({\n        bitspersample: result.bitsPerSample,\n        channelcount: result.channels,\n        connectivity: connectivity.Unknown,\n        manufacturer: \"Speech SDK\",\n        model: \"File\",\n        samplerate: result.samplesPerSec,\n        type: type.File\n      });\n    });\n  }\n\n  readHeader() {\n    // Read the wave header.\n    const maxHeaderSize = 128;\n    const header = this.privFile.slice(0, maxHeaderSize);\n    const headerReader = new FileReader();\n    const headerResult = new Deferred();\n\n    const processHeader = event => {\n      const header = event.target.result;\n      const view = new DataView(header);\n\n      const getWord = index => {\n        return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n      }; // RIFF 4 bytes.\n\n\n      if (\"RIFF\" !== getWord(0)) {\n        headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n      } // length, 4 bytes\n      // RIFF Type & fmt 8 bytes\n\n\n      if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n        headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n      }\n\n      const formatSize = view.getInt32(16, true);\n      const channelCount = view.getUint16(22, true);\n      const sampleRate = view.getUint32(24, true);\n      const bitsPerSample = view.getUint16(34, true); // Confirm if header is 44 bytes long.\n\n      let pos = 36 + Math.max(formatSize - 16, 0);\n\n      for (; getWord(pos) !== \"data\"; pos += 2) {\n        if (pos > maxHeaderSize - 8) {\n          headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n        }\n      }\n\n      this.privHeaderEnd = pos + 8;\n      headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n    };\n\n    headerReader.onload = processHeader;\n    headerReader.readAsArrayBuffer(header);\n    return headerResult.promise;\n  }\n\n  upload(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.turnOn();\n      const format = yield this.privAudioFormatPromise;\n      const reader = new FileReader();\n      const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n      this.privStreams[audioNodeId] = stream;\n\n      const processFile = event => {\n        if (stream.isClosed) {\n          return; // output stream was closed (somebody called TurnOff). We're done here.\n        }\n\n        stream.writeStreamChunk({\n          buffer: reader.result,\n          isEnd: false,\n          timeReceived: Date.now()\n        });\n        stream.close();\n      };\n\n      reader.onload = processFile;\n\n      reader.onerror = event => {\n        const errorMsg = `Error occurred while processing '${this.privFile.name}'. ${event}`;\n        this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\n        throw new Error(errorMsg);\n      };\n\n      const chunk = this.privFile.slice(this.privHeaderEnd);\n      reader.readAsArrayBuffer(chunk);\n      return stream;\n    });\n  }\n\n}","map":{"version":3,"sources":["src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\n\r\nexport class FileAudioSource implements IAudioSource {\r\n\r\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privFile: File;\r\n\r\n    private privHeaderEnd: number = 44;\r\n\r\n    public constructor(file: File, audioSourceId?: string) {\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privFile = file;\r\n\r\n        // Read the header.\r\n        this.privAudioFormatPromise = this.readHeader();\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return this.privAudioFormatPromise;\r\n    }\r\n\r\n    public get blob(): Promise<Blob | Buffer> {\r\n        return Promise.resolve(this.privFile);\r\n    }\r\n\r\n    public turnOn = (): Promise<void> => {\r\n        if (typeof FileReader === \"undefined\") {\r\n            const errorMsg = \"Browser does not support FileReader.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // initialization error - no streamid at this point\r\n            return Promise.reject(errorMsg);\r\n        } else if (this.privFile.name.lastIndexOf(\".wav\") !== this.privFile.name.length - 4) {\r\n            const errorMsg = this.privFile.name + \" is not supported. Only WAVE files are allowed at the moment.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return Promise.reject(errorMsg);\r\n        }\r\n\r\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n        return;\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = async (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        const stream: Stream<ArrayBuffer> = await this.upload(audioNodeId);\r\n\r\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n        return Promise.resolve({\r\n            detach: async (): Promise<void> => {\r\n                stream.readEnded();\r\n                delete this.privStreams[audioNodeId];\r\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                await this.turnOff();\r\n            },\r\n            id: () => {\r\n                return audioNodeId;\r\n            },\r\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => {\r\n                return stream.read();\r\n            },\r\n        });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff = (): Promise<void> => {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream && !stream.isClosed) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.privAudioFormatPromise.then<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl) => {\r\n            return Promise.resolve({\r\n                bitspersample: result.bitsPerSample,\r\n                channelcount: result.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: \"File\",\r\n                samplerate: result.samplesPerSec,\r\n                type: type.File,\r\n            });\r\n        });\r\n    }\r\n\r\n    private readHeader(): Promise<AudioStreamFormatImpl> {\r\n        // Read the wave header.\r\n        const maxHeaderSize: number = 128;\r\n        const header: Blob = this.privFile.slice(0, maxHeaderSize);\r\n        const headerReader: FileReader = new FileReader();\r\n\r\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\r\n\r\n        const processHeader = (event: Event): void => {\r\n            const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n\r\n            const view: DataView = new DataView(header);\r\n\r\n            const getWord = (index: number): string => {\r\n                return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\r\n            };\r\n\r\n            // RIFF 4 bytes.\r\n            if (\"RIFF\" !== getWord(0)) {\r\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\r\n            }\r\n\r\n            // length, 4 bytes\r\n            // RIFF Type & fmt 8 bytes\r\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\r\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\r\n            }\r\n\r\n            const formatSize: number = view.getInt32(16, true);\r\n            const channelCount: number = view.getUint16(22, true);\r\n            const sampleRate: number = view.getUint32(24, true);\r\n            const bitsPerSample: number = view.getUint16(34, true);\r\n            // Confirm if header is 44 bytes long.\r\n            let pos: number = 36 + Math.max(formatSize - 16, 0);\r\n            for (; getWord(pos) !== \"data\"; pos += 2) {\r\n              if (pos > maxHeaderSize - 8) {\r\n                  headerResult.reject(\"Invalid WAV header in file, data block was not found\");\r\n              }\r\n            }\r\n\r\n            this.privHeaderEnd = pos + 8;\r\n\r\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\r\n        };\r\n\r\n        headerReader.onload = processHeader;\r\n        headerReader.readAsArrayBuffer(header);\r\n        return headerResult.promise;\r\n    }\r\n\r\n    private async upload(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\r\n        await this.turnOn();\r\n\r\n        const format: AudioStreamFormatImpl = await this.privAudioFormatPromise;\r\n        const reader: FileReader = new FileReader();\r\n        const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\r\n\r\n        this.privStreams[audioNodeId] = stream;\r\n\r\n        const processFile = (event: Event): void => {\r\n            if (stream.isClosed) {\r\n                return; // output stream was closed (somebody called TurnOff). We're done here.\r\n            }\r\n\r\n            stream.writeStreamChunk({\r\n                buffer: reader.result as ArrayBuffer,\r\n                isEnd: false,\r\n                timeReceived: Date.now(),\r\n            });\r\n            stream.close();\r\n        };\r\n\r\n        reader.onload = processFile;\r\n\r\n        reader.onerror = (event: ProgressEvent) => {\r\n            const errorMsg = `Error occurred while processing '${this.privFile.name}'. ${event}`;\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\r\n            throw new Error(errorMsg);\r\n        };\r\n\r\n        const chunk = this.privFile.slice(this.privHeaderEnd);\r\n        reader.readAsArrayBuffer(chunk);\r\n\r\n        return stream;\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}
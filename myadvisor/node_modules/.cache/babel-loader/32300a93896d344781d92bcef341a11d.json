{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = queueIncomingActivitySaga;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _effects = require(\"redux-saga/effects\");\n\nvar _queueIncomingActivity = require(\"../actions/queueIncomingActivity\");\n\nvar _activities = _interopRequireWildcard(require(\"../selectors/activities\"));\n\nvar _activityFromBot = _interopRequireDefault(require(\"../definitions/activityFromBot\"));\n\nvar _incomingActivity = _interopRequireWildcard(require(\"../actions/incomingActivity\"));\n\nvar _setSuggestedActions = _interopRequireDefault(require(\"../actions/setSuggestedActions\"));\n\nvar _sleep = _interopRequireDefault(require(\"../utils/sleep\"));\n\nvar _whileConnected = _interopRequireDefault(require(\"./effects/whileConnected\"));\n\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(takeEveryAndSelect),\n    _marked2 = /*#__PURE__*/_regenerator[\"default\"].mark(waitForActivityId),\n    _marked3 = /*#__PURE__*/_regenerator[\"default\"].mark(queueIncomingActivity),\n    _marked4 = /*#__PURE__*/_regenerator[\"default\"].mark(queueIncomingActivitySaga); // We will hold up the replying activity if the originating activity did not arrive, up to 5 seconds.\n\n\nvar REPLY_TIMEOUT = 5000;\n\nfunction takeEveryAndSelect(actionType, selector, fn) {\n  var action, state;\n  return _regenerator[\"default\"].wrap(function takeEveryAndSelect$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return (0, _effects.cancelled)();\n\n        case 2:\n          if (_context.sent) {\n            _context.next = 13;\n            break;\n          }\n\n          _context.next = 5;\n          return (0, _effects.take)(actionType);\n\n        case 5:\n          action = _context.sent;\n          _context.next = 8;\n          return (0, _effects.select)(selector);\n\n        case 8:\n          state = _context.sent;\n          _context.next = 11;\n          return (0, _effects.fork)(fn, action, state);\n\n        case 11:\n          _context.next = 0;\n          break;\n\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // Wait for specific activity to arrive in the transcript.\n// We will use the initial set of activities to close time gaps between select() and take().\n// If another activity with the same \"replyToId\" is already rendered (in the \"activities\" array),\n// we will skip the wait as we already waited long enough for the missing activity to show up.\n\n\nfunction waitForActivityId(replyToId, initialActivities) {\n  var activities, replied, _yield$take, activity;\n\n  return _regenerator[\"default\"].wrap(function waitForActivityId$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          activities = initialActivities;\n\n        case 1:\n          replied = activities.find(function (activity) {\n            return activity.id === replyToId || activity.replyToId === replyToId;\n          });\n\n          if (!replied) {\n            _context2.next = 4;\n            break;\n          }\n\n          return _context2.abrupt(\"break\", 15);\n\n        case 4:\n          _context2.next = 6;\n          return (0, _effects.take)(_incomingActivity.INCOMING_ACTIVITY);\n\n        case 6:\n          _yield$take = _context2.sent;\n          activity = _yield$take.payload.activity;\n\n          if (!(activity.id === replyToId)) {\n            _context2.next = 10;\n            break;\n          }\n\n          return _context2.abrupt(\"break\", 15);\n\n        case 10:\n          _context2.next = 12;\n          return (0, _effects.select)(_activities[\"default\"]);\n\n        case 12:\n          activities = _context2.sent;\n\n        case 13:\n          _context2.next = 1;\n          break;\n\n        case 15:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nfunction queueIncomingActivity(_ref) {\n  var userID;\n  return _regenerator[\"default\"].wrap(function queueIncomingActivity$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          userID = _ref.userID;\n          _context4.next = 3;\n          return takeEveryAndSelect(_queueIncomingActivity.QUEUE_INCOMING_ACTIVITY, _activities[\"default\"], /*#__PURE__*/_regenerator[\"default\"].mark(function queueIncomingActivity(_ref2, initialActivities) {\n            var activity, replyToId, initialBotActivities, result, messageActivities, lastMessageActivity, _lastMessageActivity$, actions, to;\n\n            return _regenerator[\"default\"].wrap(function queueIncomingActivity$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    activity = _ref2.payload.activity; // This is for resolving an accessibility issue.\n                    // If the incoming activity has \"replyToId\" field, hold on it until the activity replied to is in the transcript, then release this one.\n\n                    replyToId = activity.replyToId;\n                    initialBotActivities = initialActivities.filter(function (_ref3) {\n                      var role = _ref3.from.role;\n                      return role === 'bot';\n                    }); // To speed up the first activity render time, we do not delay the first activity from the bot.\n                    // Even if it is the first activity from the bot, the bot might be \"replying\" to the \"conversationUpdate\" event.\n                    // Thus, the \"replyToId\" will always be there even it is the first activity in the conversation.\n\n                    if (!(replyToId && initialBotActivities.length)) {\n                      _context3.next = 8;\n                      break;\n                    }\n\n                    _context3.next = 6;\n                    return (0, _effects.race)({\n                      _: waitForActivityId(replyToId, initialActivities),\n                      timeout: (0, _effects.call)(_sleep[\"default\"], REPLY_TIMEOUT)\n                    });\n\n                  case 6:\n                    result = _context3.sent;\n\n                    if ('timeout' in result) {\n                      console.warn(\"botframework-webchat: Timed out while waiting for activity \\\"\".concat(replyToId, \"\\\" which activity \\\"\").concat(activity.id, \"\\\" is replying to.\"), {\n                        activity: activity,\n                        replyToId: replyToId\n                      });\n                    }\n\n                  case 8:\n                    _context3.next = 10;\n                    return (0, _effects.put)((0, _incomingActivity[\"default\"])(activity));\n\n                  case 10:\n                    _context3.next = 12;\n                    return (0, _effects.select)((0, _activities.ofType)('message'));\n\n                  case 12:\n                    messageActivities = _context3.sent;\n                    lastMessageActivity = messageActivities[messageActivities.length - 1];\n\n                    if (!(0, _activityFromBot[\"default\"])(lastMessageActivity)) {\n                      _context3.next = 20;\n                      break;\n                    }\n\n                    _lastMessageActivity$ = lastMessageActivity.suggestedActions;\n                    _lastMessageActivity$ = _lastMessageActivity$ === void 0 ? {} : _lastMessageActivity$;\n                    actions = _lastMessageActivity$.actions, to = _lastMessageActivity$.to; // If suggested actions is not destined to anyone, or is destined to the user, show it.\n                    // In other words, if suggested actions is destined to someone else, don't show it.\n\n                    _context3.next = 20;\n                    return (0, _effects.put)((0, _setSuggestedActions[\"default\"])(to && to.length && !to.includes(userID) ? null : actions));\n\n                  case 20:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, queueIncomingActivity);\n          }));\n\n        case 3:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction queueIncomingActivitySaga() {\n  return _regenerator[\"default\"].wrap(function queueIncomingActivitySaga$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return (0, _whileConnected[\"default\"])(queueIncomingActivity);\n\n        case 2:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked4);\n}","map":{"version":3,"sources":["../../src/sagas/queueIncomingActivitySaga.js"],"names":["REPLY_TIMEOUT","takeEveryAndSelect","action","state","waitForActivityId","activities","replied","activity","INCOMING_ACTIVITY","activitiesSelector","queueIncomingActivity","userID","QUEUE_INCOMING_ACTIVITY","replyToId","initialBotActivities","role","result","_","timeout","sleep","console","messageActivities","lastMessageActivity","actions","to","queueIncomingActivitySaga"],"mappings":"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","sourcesContent":["import { call, cancelled, fork, put, race, select, take } from 'redux-saga/effects';\n\nimport { QUEUE_INCOMING_ACTIVITY } from '../actions/queueIncomingActivity';\nimport activitiesSelector, { ofType as activitiesOfType } from '../selectors/activities';\nimport activityFromBot from '../definitions/activityFromBot';\nimport incomingActivity, { INCOMING_ACTIVITY } from '../actions/incomingActivity';\nimport setSuggestedActions from '../actions/setSuggestedActions';\nimport sleep from '../utils/sleep';\nimport whileConnected from './effects/whileConnected';\n\n// We will hold up the replying activity if the originating activity did not arrive, up to 5 seconds.\nconst REPLY_TIMEOUT = 5000;\n\nfunction* takeEveryAndSelect(actionType, selector, fn) {\n  // select() will free up the code execution.\n  // If we pair up with takeEvery(), it will allow actions to slip through.\n  // Thus, we are writing one that don't use takeEvery().\n  while (!(yield cancelled())) {\n    const action = yield take(actionType);\n    const state = yield select(selector);\n\n    yield fork(fn, action, state);\n  }\n}\n\n// Wait for specific activity to arrive in the transcript.\n// We will use the initial set of activities to close time gaps between select() and take().\n// If another activity with the same \"replyToId\" is already rendered (in the \"activities\" array),\n// we will skip the wait as we already waited long enough for the missing activity to show up.\nfunction* waitForActivityId(replyToId, initialActivities) {\n  let activities = initialActivities;\n\n  for (;;) {\n    const replied = activities.find(activity => activity.id === replyToId || activity.replyToId === replyToId);\n\n    if (replied) {\n      break;\n    }\n\n    const {\n      payload: { activity }\n    } = yield take(INCOMING_ACTIVITY);\n\n    if (activity.id === replyToId) {\n      break;\n    }\n\n    activities = yield select(activitiesSelector);\n  }\n}\n\nfunction* queueIncomingActivity({ userID }) {\n  yield takeEveryAndSelect(QUEUE_INCOMING_ACTIVITY, activitiesSelector, function* queueIncomingActivity(\n    { payload: { activity } },\n    initialActivities\n  ) {\n    // This is for resolving an accessibility issue.\n    // If the incoming activity has \"replyToId\" field, hold on it until the activity replied to is in the transcript, then release this one.\n    const { replyToId } = activity;\n    const initialBotActivities = initialActivities.filter(({ from: { role } }) => role === 'bot');\n\n    // To speed up the first activity render time, we do not delay the first activity from the bot.\n    // Even if it is the first activity from the bot, the bot might be \"replying\" to the \"conversationUpdate\" event.\n    // Thus, the \"replyToId\" will always be there even it is the first activity in the conversation.\n    if (replyToId && initialBotActivities.length) {\n      // Either the activity replied to is in the transcript or after timeout.\n      const result = yield race({\n        _: waitForActivityId(replyToId, initialActivities),\n        timeout: call(sleep, REPLY_TIMEOUT)\n      });\n\n      if ('timeout' in result) {\n        console.warn(\n          `botframework-webchat: Timed out while waiting for activity \"${replyToId}\" which activity \"${activity.id}\" is replying to.`,\n          {\n            activity,\n            replyToId\n          }\n        );\n      }\n    }\n\n    yield put(incomingActivity(activity));\n\n    // Update suggested actions\n    // TODO: [P3] We could put this logic inside reducer to minimize number of actions dispatched.\n    const messageActivities = yield select(activitiesOfType('message'));\n    const lastMessageActivity = messageActivities[messageActivities.length - 1];\n\n    if (activityFromBot(lastMessageActivity)) {\n      const { suggestedActions: { actions, to } = {} } = lastMessageActivity;\n\n      // If suggested actions is not destined to anyone, or is destined to the user, show it.\n      // In other words, if suggested actions is destined to someone else, don't show it.\n      yield put(setSuggestedActions(to && to.length && !to.includes(userID) ? null : actions));\n    }\n  });\n}\n\nexport default function* queueIncomingActivitySaga() {\n  yield whileConnected(queueIncomingActivity);\n}\n"],"sourceRoot":"core:///"},"metadata":{},"sourceType":"script"}
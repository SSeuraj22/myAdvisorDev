"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyMiddleware;
exports.forLegacyRenderer = forLegacyRenderer;
exports.forRenderer = forRenderer;

var _react = _interopRequireWildcard(require("react"));

var _concatMiddleware = _interopRequireDefault(require("./concatMiddleware"));

var _ErrorBox = _interopRequireDefault(require("../internal/ErrorBox"));

var _UserlandBoundary = _interopRequireDefault(require("./UserlandBoundary"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function applyMiddleware(type) {
  for (var _len = arguments.length, middleware = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    middleware[_key - 1] = arguments[_key];
  }

  return function () {
    return _concatMiddleware.default.apply(void 0, middleware).apply(void 0, arguments)(function () {
      throw new Error("reached terminator of ".concat(type));
    });
  };
}

function forLegacyRenderer(type) {
  for (var _len2 = arguments.length, middleware = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    middleware[_key2 - 1] = arguments[_key2];
  }

  return function () {
    var fn = _concatMiddleware.default.apply(void 0, middleware).apply(void 0, arguments)(function () {
      throw new Error("reached terminator of ".concat(type));
    });

    return function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return /*#__PURE__*/_react.default.createElement(_UserlandBoundary.default, {
        type: "render of ".concat(type)
      }, function () {
        try {
          return fn.apply(void 0, args);
        } catch (err) {
          return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
            error: err,
            type: "render of ".concat(type)
          });
        }
      });
    };
  };
}
/**
 *
 * @param {string} type Required. String equivalent of type of container to be rendered.
 * @param { strict = false } - Used to enforce new middleware format which cooperates with new activity grouping.
 * @see See {@link https://github.com/microsoft/BotFramework-WebChat/blob/master/CHANGELOG.md#4100---2020-08-18} and {@link https://github.com/microsoft/BotFramework-WebChat/pull/3365} for middleware breaking changes.
 * @param  {middleware[]} middleware list of middleware to be applied.
 * 'createRendererArgs' is "what to render"; for example, an activity.
 * @returns  Returns a function if there is a renderer *committed* to render OR returns false if nothing should be rendered.
 */


function forRenderer(type) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$strict = _ref.strict,
      strict = _ref$strict === void 0 ? false : _ref$strict;

  for (var _len4 = arguments.length, middleware = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    middleware[_key4 - 2] = arguments[_key4];
  }

  return function () {
    var runMiddleware = _concatMiddleware.default.apply(void 0, middleware).apply(void 0, arguments)(function () {
      return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
        error: new Error("reached terminator of ".concat(type)),
        type: type
      });
    });

    return function () {
      try {
        var render = runMiddleware.apply(void 0, arguments);

        if (!render) {
          return false;
        } else if ( /*#__PURE__*/(0, _react.isValidElement)(render)) {
          if (strict) {
            console.error("botframework-webchat: ".concat(type, " should only return either false or a render function."));
            return false;
          }

          return /*#__PURE__*/_react.default.createElement(_UserlandBoundary.default, {
            type: "render of ".concat(type)
          }, render);
        }

        return function () {
          for (var _len5 = arguments.length, renderTimeArgs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            renderTimeArgs[_key5] = arguments[_key5];
          }

          return /*#__PURE__*/_react.default.createElement(_UserlandBoundary.default, {
            type: "render of ".concat(type)
          }, function () {
            try {
              var element = render.apply(void 0, renderTimeArgs);

              if (strict && ! /*#__PURE__*/(0, _react.isValidElement)(element)) {
                console.error("botframework-webchat: ".concat(type, " should return React element only."));
              }

              return element;
            } catch (err) {
              return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
                error: err,
                type: "render of ".concat(type)
              });
            }
          });
        };
      } catch (err) {
        return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
          error: err,
          type: "render of ".concat(type)
        });
      }
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ob29rcy9taWRkbGV3YXJlL2FwcGx5TWlkZGxld2FyZS5qcyJdLCJuYW1lcyI6WyJhcHBseU1pZGRsZXdhcmUiLCJ0eXBlIiwibWlkZGxld2FyZSIsImNvbmNhdE1pZGRsZXdhcmUiLCJFcnJvciIsImZvckxlZ2FjeVJlbmRlcmVyIiwiZm4iLCJhcmdzIiwiZXJyIiwiZm9yUmVuZGVyZXIiLCJzdHJpY3QiLCJydW5NaWRkbGV3YXJlIiwicmVuZGVyIiwiY29uc29sZSIsImVycm9yIiwicmVuZGVyVGltZUFyZ3MiLCJlbGVtZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVlLFNBQVNBLGVBQVQsQ0FBeUJDLElBQXpCLEVBQThDO0FBQUEsb0NBQVpDLFVBQVk7QUFBWkEsSUFBQUEsVUFBWTtBQUFBOztBQUMzRCxTQUFPO0FBQUEsV0FDTEMsd0NBQW9CRCxVQUFwQiwyQkFBOEMsWUFBTTtBQUNsRCxZQUFNLElBQUlFLEtBQUosaUNBQW1DSCxJQUFuQyxFQUFOO0FBQ0QsS0FGRCxDQURLO0FBQUEsR0FBUDtBQUlEOztBQUVNLFNBQVNJLGlCQUFULENBQTJCSixJQUEzQixFQUFnRDtBQUFBLHFDQUFaQyxVQUFZO0FBQVpBLElBQUFBLFVBQVk7QUFBQTs7QUFDckQsU0FBTyxZQUFrQjtBQUN2QixRQUFNSSxFQUFFLEdBQUdILHdDQUFvQkQsVUFBcEIsMkJBQThDLFlBQU07QUFDN0QsWUFBTSxJQUFJRSxLQUFKLGlDQUFtQ0gsSUFBbkMsRUFBTjtBQUNELEtBRlUsQ0FBWDs7QUFJQSxXQUFPO0FBQUEseUNBQUlNLElBQUo7QUFBSUEsUUFBQUEsSUFBSjtBQUFBOztBQUFBLDBCQUNMLDZCQUFDLHlCQUFEO0FBQWtCLFFBQUEsSUFBSSxzQkFBZU4sSUFBZjtBQUF0QixTQUNHLFlBQU07QUFDTCxZQUFJO0FBQ0YsaUJBQU9LLEVBQUUsTUFBRixTQUFNQyxJQUFOLENBQVA7QUFDRCxTQUZELENBRUUsT0FBT0MsR0FBUCxFQUFZO0FBQ1osOEJBQU8sNkJBQUMsaUJBQUQ7QUFBVSxZQUFBLEtBQUssRUFBRUEsR0FBakI7QUFBc0IsWUFBQSxJQUFJLHNCQUFlUCxJQUFmO0FBQTFCLFlBQVA7QUFDRDtBQUNGLE9BUEgsQ0FESztBQUFBLEtBQVA7QUFXRCxHQWhCRDtBQWlCRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU1EsV0FBVCxDQUFxQlIsSUFBckIsRUFBbUU7QUFBQSxpRkFBbkIsRUFBbUI7QUFBQSx5QkFBdENTLE1BQXNDO0FBQUEsTUFBdENBLE1BQXNDLDRCQUE3QixLQUE2Qjs7QUFBQSxxQ0FBWlIsVUFBWTtBQUFaQSxJQUFBQSxVQUFZO0FBQUE7O0FBQ3hFLFNBQU8sWUFBa0I7QUFDdkIsUUFBTVMsYUFBYSxHQUFHUix3Q0FBb0JELFVBQXBCLDJCQUE4QztBQUFBLDBCQUNsRSw2QkFBQyxpQkFBRDtBQUFVLFFBQUEsS0FBSyxFQUFFLElBQUlFLEtBQUosaUNBQW1DSCxJQUFuQyxFQUFqQjtBQUE2RCxRQUFBLElBQUksRUFBRUE7QUFBbkUsUUFEa0U7QUFBQSxLQUE5QyxDQUF0Qjs7QUFJQSxXQUFPLFlBQTJCO0FBQ2hDLFVBQUk7QUFDRixZQUFNVyxNQUFNLEdBQUdELGFBQWEsTUFBYixtQkFBZjs7QUFFQSxZQUFJLENBQUNDLE1BQUwsRUFBYTtBQUNYLGlCQUFPLEtBQVA7QUFDRCxTQUZELE1BRU8sa0JBQUksMkJBQWVBLE1BQWYsQ0FBSixFQUE0QjtBQUNqQyxjQUFJRixNQUFKLEVBQVk7QUFDVkcsWUFBQUEsT0FBTyxDQUFDQyxLQUFSLGlDQUF1Q2IsSUFBdkM7QUFFQSxtQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsOEJBQU8sNkJBQUMseUJBQUQ7QUFBa0IsWUFBQSxJQUFJLHNCQUFlQSxJQUFmO0FBQXRCLGFBQThDVyxNQUE5QyxDQUFQO0FBQ0Q7O0FBRUQsZUFBTztBQUFBLDZDQUFJRyxjQUFKO0FBQUlBLFlBQUFBLGNBQUo7QUFBQTs7QUFBQSw4QkFDTCw2QkFBQyx5QkFBRDtBQUFrQixZQUFBLElBQUksc0JBQWVkLElBQWY7QUFBdEIsYUFDRyxZQUFNO0FBQ0wsZ0JBQUk7QUFDRixrQkFBTWUsT0FBTyxHQUFHSixNQUFNLE1BQU4sU0FBVUcsY0FBVixDQUFoQjs7QUFFQSxrQkFBSUwsTUFBTSxJQUFJLGVBQUMsMkJBQWVNLE9BQWYsQ0FBZixFQUF3QztBQUN0Q0gsZ0JBQUFBLE9BQU8sQ0FBQ0MsS0FBUixpQ0FBdUNiLElBQXZDO0FBQ0Q7O0FBRUQscUJBQU9lLE9BQVA7QUFDRCxhQVJELENBUUUsT0FBT1IsR0FBUCxFQUFZO0FBQ1osa0NBQU8sNkJBQUMsaUJBQUQ7QUFBVSxnQkFBQSxLQUFLLEVBQUVBLEdBQWpCO0FBQXNCLGdCQUFBLElBQUksc0JBQWVQLElBQWY7QUFBMUIsZ0JBQVA7QUFDRDtBQUNGLFdBYkgsQ0FESztBQUFBLFNBQVA7QUFpQkQsT0FoQ0QsQ0FnQ0UsT0FBT08sR0FBUCxFQUFZO0FBQ1osNEJBQU8sNkJBQUMsaUJBQUQ7QUFBVSxVQUFBLEtBQUssRUFBRUEsR0FBakI7QUFBc0IsVUFBQSxJQUFJLHNCQUFlUCxJQUFmO0FBQTFCLFVBQVA7QUFDRDtBQUNGLEtBcENEO0FBcUNELEdBMUNEO0FBMkNEIiwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgaXNWYWxpZEVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBjb25jYXRNaWRkbGV3YXJlIGZyb20gJy4vY29uY2F0TWlkZGxld2FyZSc7XG5pbXBvcnQgRXJyb3JCb3ggZnJvbSAnLi4vaW50ZXJuYWwvRXJyb3JCb3gnO1xuaW1wb3J0IFVzZXJsYW5kQm91bmRhcnkgZnJvbSAnLi9Vc2VybGFuZEJvdW5kYXJ5JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKHR5cGUsIC4uLm1pZGRsZXdhcmUpIHtcbiAgcmV0dXJuICguLi5zZXR1cEFyZ3MpID0+XG4gICAgY29uY2F0TWlkZGxld2FyZSguLi5taWRkbGV3YXJlKSguLi5zZXR1cEFyZ3MpKCgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVhY2hlZCB0ZXJtaW5hdG9yIG9mICR7dHlwZX1gKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvckxlZ2FjeVJlbmRlcmVyKHR5cGUsIC4uLm1pZGRsZXdhcmUpIHtcbiAgcmV0dXJuICguLi5zZXR1cEFyZ3MpID0+IHtcbiAgICBjb25zdCBmbiA9IGNvbmNhdE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZSkoLi4uc2V0dXBBcmdzKSgoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlYWNoZWQgdGVybWluYXRvciBvZiAke3R5cGV9YCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChcbiAgICAgIDxVc2VybGFuZEJvdW5kYXJ5IHR5cGU9e2ByZW5kZXIgb2YgJHt0eXBlfWB9PlxuICAgICAgICB7KCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oLi4uYXJncyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gPEVycm9yQm94IGVycm9yPXtlcnJ9IHR5cGU9e2ByZW5kZXIgb2YgJHt0eXBlfWB9IC8+O1xuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgIDwvVXNlcmxhbmRCb3VuZGFyeT5cbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBSZXF1aXJlZC4gU3RyaW5nIGVxdWl2YWxlbnQgb2YgdHlwZSBvZiBjb250YWluZXIgdG8gYmUgcmVuZGVyZWQuXG4gKiBAcGFyYW0geyBzdHJpY3QgPSBmYWxzZSB9IC0gVXNlZCB0byBlbmZvcmNlIG5ldyBtaWRkbGV3YXJlIGZvcm1hdCB3aGljaCBjb29wZXJhdGVzIHdpdGggbmV3IGFjdGl2aXR5IGdyb3VwaW5nLlxuICogQHNlZSBTZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvQm90RnJhbWV3b3JrLVdlYkNoYXQvYmxvYi9tYXN0ZXIvQ0hBTkdFTE9HLm1kIzQxMDAtLS0yMDIwLTA4LTE4fSBhbmQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvQm90RnJhbWV3b3JrLVdlYkNoYXQvcHVsbC8zMzY1fSBmb3IgbWlkZGxld2FyZSBicmVha2luZyBjaGFuZ2VzLlxuICogQHBhcmFtICB7bWlkZGxld2FyZVtdfSBtaWRkbGV3YXJlIGxpc3Qgb2YgbWlkZGxld2FyZSB0byBiZSBhcHBsaWVkLlxuICogJ2NyZWF0ZVJlbmRlcmVyQXJncycgaXMgXCJ3aGF0IHRvIHJlbmRlclwiOyBmb3IgZXhhbXBsZSwgYW4gYWN0aXZpdHkuXG4gKiBAcmV0dXJucyAgUmV0dXJucyBhIGZ1bmN0aW9uIGlmIHRoZXJlIGlzIGEgcmVuZGVyZXIgKmNvbW1pdHRlZCogdG8gcmVuZGVyIE9SIHJldHVybnMgZmFsc2UgaWYgbm90aGluZyBzaG91bGQgYmUgcmVuZGVyZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JSZW5kZXJlcih0eXBlLCB7IHN0cmljdCA9IGZhbHNlIH0gPSB7fSwgLi4ubWlkZGxld2FyZSkge1xuICByZXR1cm4gKC4uLnNldHVwQXJncykgPT4ge1xuICAgIGNvbnN0IHJ1bk1pZGRsZXdhcmUgPSBjb25jYXRNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmUpKC4uLnNldHVwQXJncykoKCkgPT4gKFxuICAgICAgPEVycm9yQm94IGVycm9yPXtuZXcgRXJyb3IoYHJlYWNoZWQgdGVybWluYXRvciBvZiAke3R5cGV9YCl9IHR5cGU9e3R5cGV9IC8+XG4gICAgKSk7XG5cbiAgICByZXR1cm4gKC4uLmNyZWF0ZVJlbmRlcmVyQXJncykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVuZGVyID0gcnVuTWlkZGxld2FyZSguLi5jcmVhdGVSZW5kZXJlckFyZ3MpO1xuXG4gICAgICAgIGlmICghcmVuZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KHJlbmRlcikpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBib3RmcmFtZXdvcmstd2ViY2hhdDogJHt0eXBlfSBzaG91bGQgb25seSByZXR1cm4gZWl0aGVyIGZhbHNlIG9yIGEgcmVuZGVyIGZ1bmN0aW9uLmApO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIDxVc2VybGFuZEJvdW5kYXJ5IHR5cGU9e2ByZW5kZXIgb2YgJHt0eXBlfWB9PntyZW5kZXJ9PC9Vc2VybGFuZEJvdW5kYXJ5PjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoLi4ucmVuZGVyVGltZUFyZ3MpID0+IChcbiAgICAgICAgICA8VXNlcmxhbmRCb3VuZGFyeSB0eXBlPXtgcmVuZGVyIG9mICR7dHlwZX1gfT5cbiAgICAgICAgICAgIHsoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlbmRlciguLi5yZW5kZXJUaW1lQXJncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmICFpc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgYm90ZnJhbWV3b3JrLXdlYmNoYXQ6ICR7dHlwZX0gc2hvdWxkIHJldHVybiBSZWFjdCBlbGVtZW50IG9ubHkuYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiA8RXJyb3JCb3ggZXJyb3I9e2Vycn0gdHlwZT17YHJlbmRlciBvZiAke3R5cGV9YH0gLz47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPC9Vc2VybGFuZEJvdW5kYXJ5PlxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiA8RXJyb3JCb3ggZXJyb3I9e2Vycn0gdHlwZT17YHJlbmRlciBvZiAke3R5cGV9YH0gLz47XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbiJdfQ==
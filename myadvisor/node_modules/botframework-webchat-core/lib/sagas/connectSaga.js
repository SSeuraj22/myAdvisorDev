"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _callee;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _effects = require("redux-saga/effects");

var _botframeworkDirectlinejs = require("botframework-directlinejs");

var _jsonwebtoken = require("jsonwebtoken");

var _connect = require("../actions/connect");

var _createPromiseQueue = _interopRequireDefault(require("../createPromiseQueue"));

var _forkPut = _interopRequireDefault(require("./effects/forkPut"));

var _uniqueID = _interopRequireDefault(require("../utils/uniqueID"));

var _updateConnectionStatus = _interopRequireWildcard(require("../actions/updateConnectionStatus"));

var _disconnect = require("../actions/disconnect");

var _reconnect = require("../actions/reconnect");

var _marked = /*#__PURE__*/_regenerator["default"].mark(observeAndPutConnectionStatusUpdate),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(connectSaga),
    _marked3 = /*#__PURE__*/_regenerator["default"].mark(reconnectSaga),
    _marked4 = /*#__PURE__*/_regenerator["default"].mark(runAsyncEffect),
    _marked5 = /*#__PURE__*/_regenerator["default"].mark(takeDisconnectAsError),
    _marked6 = /*#__PURE__*/_regenerator["default"].mark(_callee);

var CONNECTING = _botframeworkDirectlinejs.ConnectionStatus.Connecting,
    ONLINE = _botframeworkDirectlinejs.ConnectionStatus.Online,
    UNINITIALIZED = _botframeworkDirectlinejs.ConnectionStatus.Uninitialized;

function randomUserID() {
  return "r_".concat((0, _uniqueID["default"])().substr(0, 10));
}

function observeAndPutConnectionStatusUpdate(directLine) {
  var connectionStatusQueue, connectionStatusSubscription, connectionStatus;
  return _regenerator["default"].wrap(function observeAndPutConnectionStatusUpdate$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          connectionStatusQueue = (0, _createPromiseQueue["default"])();
          connectionStatusSubscription = directLine.connectionStatus$.subscribe({
            next: connectionStatusQueue.push
          });
          _context.prev = 2;

        case 3:
          _context.next = 5;
          return (0, _effects.call)(connectionStatusQueue.shift);

        case 5:
          connectionStatus = _context.sent;
          _context.next = 8;
          return (0, _effects.put)((0, _updateConnectionStatus["default"])(connectionStatus));

        case 8:
          _context.next = 3;
          break;

        case 10:
          _context.prev = 10;
          connectionStatusSubscription.unsubscribe();
          return _context.finish(10);

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[2,, 10, 13]]);
} // TODO: [P2] We should move this check and rectification to DirectLineJS.


function rectifyUserID(directLine, userIDFromAction) {
  var token = directLine.token;

  var _ref = (0, _jsonwebtoken.decode)(token) || {},
      userIDFromToken = _ref.user;

  var result = {
    fromAction: userIDFromAction,
    fromToken: userIDFromToken
  };

  if (userIDFromToken) {
    if (userIDFromAction && userIDFromAction !== userIDFromToken) {
      console.warn('Web Chat: user ID is both specified in the Direct Line token and passed in, will use the user ID from the token.');
    }

    result["final"] = userIDFromToken;
  } else if (userIDFromAction) {
    if (typeof userIDFromAction !== 'string') {
      console.warn('Web Chat: user ID must be a string.');
      result["final"] = randomUserID();
    } else if (/^dl_/.test(userIDFromAction)) {
      console.warn('Web Chat: user ID prefixed with "dl_" is reserved and must be embedded into the Direct Line token to prevent forgery.');
      result["final"] = randomUserID();
    } else {
      result["final"] = userIDFromAction;
    }
  } else {
    result["final"] = randomUserID();
  }

  return result;
} // We could make this a Promise instead of saga (function generator) to make the code cleaner, if:
// 1. We found a way to cancel Promise
// 2. subscribe() are shared amongst all subscriptions, e.g. turn Observable into events


function connectSaga(directLine) {
  var activitySubscription, unsubscribeActivity, _yield$take, connectionStatus;

  return _regenerator["default"].wrap(function connectSaga$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          // DirectLineJS starts the connection only after the first subscriber for activity$, not connectionStatus$
          activitySubscription = directLine.activity$.subscribe({
            next: function next() {
              return 0;
            }
          });
          unsubscribeActivity = activitySubscription.unsubscribe.bind(activitySubscription);
          _context2.prev = 2;

        case 3:
          _context2.next = 5;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 5:
          _yield$take = _context2.sent;
          connectionStatus = _yield$take.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt("return", function () {
            unsubscribeActivity();
            directLine.end();
          });

        case 11:
          if (!(connectionStatus !== UNINITIALIZED && connectionStatus !== CONNECTING)) {
            _context2.next = 13;
            break;
          }

          throw new Error("Failed to connect, DirectLineJS returned ".concat(connectionStatus, "."));

        case 13:
          _context2.next = 3;
          break;

        case 15:
          _context2.next = 21;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t0 = _context2["catch"](2);
          // We will unsubscribe if we failed to connect or got cancelled only.
          // We should not unsubscribe in happy case, because DirectLineJS should relying on the subscription to connect/disconnect.
          unsubscribeActivity();
          throw _context2.t0;

        case 21:
          _context2.prev = 21;
          _context2.next = 24;
          return (0, _effects.cancelled)();

        case 24:
          if (!_context2.sent) {
            _context2.next = 26;
            break;
          }

          unsubscribeActivity();

        case 26:
          return _context2.finish(21);

        case 27:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[2, 17, 21, 27]]);
}

function reconnectSaga() {
  var _yield$take2, connectionStatus;

  return _regenerator["default"].wrap(function reconnectSaga$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 2:
          _yield$take2 = _context3.sent;
          connectionStatus = _yield$take2.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context3.next = 8;
            break;
          }

          return _context3.abrupt("break", 12);

        case 8:
          if (!(connectionStatus !== CONNECTING)) {
            _context3.next = 10;
            break;
          }

          throw new Error("Failed to reconnect. DirectLineJS returned ".concat(connectionStatus, "."));

        case 10:
          _context3.next = 0;
          break;

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
} // This is similar to behavior of redux-promise-middleware, but using saga instead of Promise.
// We guarantee PENDING -> FULFILLING -> FULFILLED, or PENDING -> REJECTED. This will help us simplify logic in other part of code.
// Note that after the saga is cancelled, subsequent call to put() will be ignored silently.


function runAsyncEffect(_ref2, callEffectFactory) {
  var type, meta, payload, result;
  return _regenerator["default"].wrap(function runAsyncEffect$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          type = _ref2.type, meta = _ref2.meta, payload = _ref2.payload;
          _context4.prev = 1;
          _context4.next = 4;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_PENDING"),
            meta: meta,
            payload: payload
          });

        case 4:
          _context4.next = 6;
          return callEffectFactory();

        case 6:
          result = _context4.sent;
          _context4.next = 9;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_FULFILLING"),
            meta: meta,
            payload: payload
          }, {
            type: "".concat(type, "_FULFILLED"),
            meta: meta,
            payload: payload
          });

        case 9:
          return _context4.abrupt("return", result);

        case 12:
          _context4.prev = 12;
          _context4.t0 = _context4["catch"](1);
          _context4.next = 16;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_REJECTED"),
            error: true,
            meta: meta,
            payload: _context4.t0
          });

        case 16:
          throw _context4.t0;

        case 17:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[1, 12]]);
}

function takeDisconnectAsError() {
  return _regenerator["default"].wrap(function takeDisconnectAsError$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.take)(_disconnect.DISCONNECT);

        case 2:
          throw new Error('disconnected');

        case 3:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}

function runAsyncEffectUntilDisconnect(baseAction, callEffectFactory) {
  // We cannot use saga cancel() here, because cancelling saga will prohibit us from sending *_REJECTED.
  // Without REJECTED, it impacts our assumptions around PENDING/FULFILLED/REJECTED.
  return runAsyncEffect(baseAction, /*#__PURE__*/_regenerator["default"].mark(function runUntilDisconnect() {
    var _yield$race, result;

    return _regenerator["default"].wrap(function runUntilDisconnect$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return (0, _effects.race)({
              _: takeDisconnectAsError(),
              result: callEffectFactory()
            });

          case 2:
            _yield$race = _context6.sent;
            result = _yield$race.result;
            return _context6.abrupt("return", result);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, runUntilDisconnect);
  }));
}

function _callee() {
  var _loop;

  return _regenerator["default"].wrap(function _callee$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _loop = /*#__PURE__*/_regenerator["default"].mark(function _loop() {
            var _yield$take3, _yield$take3$payload, directLine, userIDFromAction, username, updateConnectionStatusTask, rectifiedUserID, meta, disconnectMeta, endDirectLine, _yield$race2, _yield$race2$updateCo, _yield$race2$updateCo2, connectionStatus;

            return _regenerator["default"].wrap(function _loop$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return (0, _effects.take)(_connect.CONNECT);

                  case 2:
                    _yield$take3 = _context7.sent;
                    _yield$take3$payload = _yield$take3.payload;
                    directLine = _yield$take3$payload.directLine;
                    userIDFromAction = _yield$take3$payload.userID;
                    username = _yield$take3$payload.username;
                    _context7.next = 9;
                    return (0, _effects.fork)(observeAndPutConnectionStatusUpdate, directLine);

                  case 9:
                    updateConnectionStatusTask = _context7.sent;
                    rectifiedUserID = rectifyUserID(directLine, userIDFromAction); // TODO: [P2] Checks if this attached subtask will get killed if the parent task is complete (peacefully), errored out, or cancelled.

                    meta = {
                      userID: rectifiedUserID["final"],
                      username: username
                    }; // Send user ID to DirectLineJS if it was specified from props of <API.Composer>.
                    // However, DirectLineJS may still prefer the user ID from token if it is burnt into the token.
                    // To prevent DirectLineJS giving false warnings, we will only call setUserId() if it is different than the token.

                    directLine.setUserId && rectifiedUserID.fromToken !== meta.userID && directLine.setUserId(meta.userID);
                    disconnectMeta = void 0; // We will dispatch CONNECT_PENDING, wait for connect completed, errored, or cancelled (thru disconnect).
                    // Then dispatch CONNECT_FULFILLED/CONNECT_REJECTED as needed.

                    _context7.prev = 14;
                    _context7.next = 17;
                    return runAsyncEffectUntilDisconnect({
                      type: _connect.CONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(connectSaga, directLine);
                    });

                  case 17:
                    endDirectLine = _context7.sent;
                    _context7.prev = 18;

                  case 19:
                    _context7.next = 21;
                    return (0, _effects.race)({
                      _: (0, _effects.take)(_disconnect.DISCONNECT),
                      updateConnectionStatusAction: (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS)
                    });

                  case 21:
                    _yield$race2 = _context7.sent;
                    _yield$race2$updateCo = _yield$race2.updateConnectionStatusAction;
                    _yield$race2$updateCo = _yield$race2$updateCo === void 0 ? {} : _yield$race2$updateCo;
                    _yield$race2$updateCo2 = _yield$race2$updateCo.payload;
                    _yield$race2$updateCo2 = _yield$race2$updateCo2 === void 0 ? {} : _yield$race2$updateCo2;
                    connectionStatus = _yield$race2$updateCo2.connectionStatus; // If it is not disconnect action, connectionStatus will not be undefined.

                    if (!(connectionStatus === CONNECTING)) {
                      _context7.next = 32;
                      break;
                    }

                    _context7.next = 30;
                    return runAsyncEffectUntilDisconnect({
                      type: _reconnect.RECONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(reconnectSaga);
                    });

                  case 30:
                    _context7.next = 38;
                    break;

                  case 32:
                    if (!(connectionStatus !== ONLINE)) {
                      _context7.next = 38;
                      break;
                    }

                    if (!(typeof connectionStatus !== 'undefined')) {
                      _context7.next = 37;
                      break;
                    }

                    throw new Error("Connection status changed to ".concat(connectionStatus));

                  case 37:
                    return _context7.abrupt("break", 40);

                  case 38:
                    _context7.next = 19;
                    break;

                  case 40:
                    _context7.prev = 40;
                    endDirectLine();
                    return _context7.finish(40);

                  case 43:
                    _context7.next = 48;
                    break;

                  case 45:
                    _context7.prev = 45;
                    _context7.t0 = _context7["catch"](14);
                    disconnectMeta = {
                      error: _context7.t0
                    };

                  case 48:
                    _context7.prev = 48;
                    _context7.next = 51;
                    return (0, _effects.cancel)(updateConnectionStatusTask);

                  case 51:
                    _context7.next = 53;
                    return (0, _forkPut["default"])({
                      type: _disconnect.DISCONNECT_PENDING,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    }, {
                      type: _disconnect.DISCONNECT_FULFILLED,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    });

                  case 53:
                    return _context7.finish(48);

                  case 54:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _loop, null, [[14, 45, 48, 54], [18,, 40, 43]]);
          });

        case 1:
          return _context8.delegateYield(_loop(), "t0", 2);

        case 2:
          _context8.next = 1;
          break;

        case 4:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked6);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zYWdhcy9jb25uZWN0U2FnYS5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZSIsImNvbm5lY3RTYWdhIiwicmVjb25uZWN0U2FnYSIsInJ1bkFzeW5jRWZmZWN0IiwidGFrZURpc2Nvbm5lY3RBc0Vycm9yIiwiQ09OTkVDVElORyIsIkNvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW5nIiwiT05MSU5FIiwiT25saW5lIiwiVU5JTklUSUFMSVpFRCIsIlVuaW5pdGlhbGl6ZWQiLCJyYW5kb21Vc2VySUQiLCJzdWJzdHIiLCJkaXJlY3RMaW5lIiwiY29ubmVjdGlvblN0YXR1c1F1ZXVlIiwiY29ubmVjdGlvblN0YXR1c1N1YnNjcmlwdGlvbiIsImNvbm5lY3Rpb25TdGF0dXMkIiwic3Vic2NyaWJlIiwibmV4dCIsInB1c2giLCJzaGlmdCIsImNvbm5lY3Rpb25TdGF0dXMiLCJ1bnN1YnNjcmliZSIsInJlY3RpZnlVc2VySUQiLCJ1c2VySURGcm9tQWN0aW9uIiwidG9rZW4iLCJ1c2VySURGcm9tVG9rZW4iLCJ1c2VyIiwicmVzdWx0IiwiZnJvbUFjdGlvbiIsImZyb21Ub2tlbiIsImNvbnNvbGUiLCJ3YXJuIiwidGVzdCIsImFjdGl2aXR5U3Vic2NyaXB0aW9uIiwiYWN0aXZpdHkkIiwidW5zdWJzY3JpYmVBY3Rpdml0eSIsImJpbmQiLCJVUERBVEVfQ09OTkVDVElPTl9TVEFUVVMiLCJwYXlsb2FkIiwiZW5kIiwiRXJyb3IiLCJjYWxsRWZmZWN0RmFjdG9yeSIsInR5cGUiLCJtZXRhIiwiZXJyb3IiLCJESVNDT05ORUNUIiwicnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QiLCJiYXNlQWN0aW9uIiwicnVuVW50aWxEaXNjb25uZWN0IiwiXyIsIkNPTk5FQ1QiLCJ1c2VySUQiLCJ1c2VybmFtZSIsInVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNUYXNrIiwicmVjdGlmaWVkVXNlcklEIiwic2V0VXNlcklkIiwiZGlzY29ubmVjdE1ldGEiLCJlbmREaXJlY3RMaW5lIiwidXBkYXRlQ29ubmVjdGlvblN0YXR1c0FjdGlvbiIsIlJFQ09OTkVDVCIsIkRJU0NPTk5FQ1RfUEVORElORyIsIkRJU0NPTk5FQ1RfRlVMRklMTEVEIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O3dEQVFVQSxtQzt5REF5REFDLFc7eURBcUNBQyxhO3lEQWlCQUMsYzt5REFnQkFDLHFCOzs7SUFySVVDLFUsR0FBNkRDLDBDLENBQXpFQyxVO0lBQWdDQyxNLEdBQXlDRiwwQyxDQUFqREcsTTtJQUErQkMsYSxHQUFrQkosMEMsQ0FBakNLLGE7O0FBRWhELFNBQVNDLFlBQVQsR0FBd0I7QUFDdEIscUJBQVksNEJBQVdDLE1BQVgsQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBckIsQ0FBWjtBQUNEOztBQUVELFNBQVViLG1DQUFWLENBQThDYyxVQUE5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDUUMsVUFBQUEscUJBRFIsR0FDZ0MscUNBRGhDO0FBRVFDLFVBQUFBLDRCQUZSLEdBRXVDRixVQUFVLENBQUNHLGlCQUFYLENBQTZCQyxTQUE3QixDQUF1QztBQUFFQyxZQUFBQSxJQUFJLEVBQUVKLHFCQUFxQixDQUFDSztBQUE5QixXQUF2QyxDQUZ2QztBQUFBOztBQUFBO0FBQUE7QUFNK0IsaUJBQU0sbUJBQUtMLHFCQUFxQixDQUFDTSxLQUEzQixDQUFOOztBQU4vQjtBQU1ZQyxVQUFBQSxnQkFOWjtBQUFBO0FBUU0saUJBQU0sa0JBQUksd0NBQXVCQSxnQkFBdkIsQ0FBSixDQUFOOztBQVJOO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBV0lOLFVBQUFBLDRCQUE0QixDQUFDTyxXQUE3QjtBQVhKOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEMsQ0FlQTs7O0FBQ0EsU0FBU0MsYUFBVCxDQUF1QlYsVUFBdkIs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QUFBQSxVQUFVLEVBQVZBO0FBQUY7QUFBN0QscUJBRkksQ0FBTjs7QUF6RVM7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiJjb3JlOi8vLyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbXCJlcnJvclwiLCB7IFwiaWdub3JlXCI6IFswLCAxMF0gfV0gKi9cblxuaW1wb3J0IHsgY2FsbCwgY2FuY2VsLCBjYW5jZWxsZWQsIGZvcmssIHB1dCwgcmFjZSwgdGFrZSB9IGZyb20gJ3JlZHV4LXNhZ2EvZWZmZWN0cyc7XG5cbmltcG9ydCB7IENvbm5lY3Rpb25TdGF0dXMgfSBmcm9tICdib3RmcmFtZXdvcmstZGlyZWN0bGluZWpzJztcbmltcG9ydCB7IGRlY29kZSB9IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5cbmltcG9ydCB7IENPTk5FQ1QgfSBmcm9tICcuLi9hY3Rpb25zL2Nvbm5lY3QnO1xuaW1wb3J0IGNyZWF0ZVByb21pc2VRdWV1ZSBmcm9tICcuLi9jcmVhdGVQcm9taXNlUXVldWUnO1xuaW1wb3J0IGZvcmtQdXQgZnJvbSAnLi9lZmZlY3RzL2ZvcmtQdXQnO1xuaW1wb3J0IHVuaXF1ZUlEIGZyb20gJy4uL3V0aWxzL3VuaXF1ZUlEJztcbmltcG9ydCB1cGRhdGVDb25uZWN0aW9uU3RhdHVzLCB7IFVQREFURV9DT05ORUNUSU9OX1NUQVRVUyB9IGZyb20gJy4uL2FjdGlvbnMvdXBkYXRlQ29ubmVjdGlvblN0YXR1cyc7XG5cbmltcG9ydCB7IERJU0NPTk5FQ1QsIERJU0NPTk5FQ1RfUEVORElORywgRElTQ09OTkVDVF9GVUxGSUxMRUQgfSBmcm9tICcuLi9hY3Rpb25zL2Rpc2Nvbm5lY3QnO1xuXG5pbXBvcnQgeyBSRUNPTk5FQ1QgfSBmcm9tICcuLi9hY3Rpb25zL3JlY29ubmVjdCc7XG5cbmNvbnN0IHsgQ29ubmVjdGluZzogQ09OTkVDVElORywgT25saW5lOiBPTkxJTkUsIFVuaW5pdGlhbGl6ZWQ6IFVOSU5JVElBTElaRUQgfSA9IENvbm5lY3Rpb25TdGF0dXM7XG5cbmZ1bmN0aW9uIHJhbmRvbVVzZXJJRCgpIHtcbiAgcmV0dXJuIGByXyR7dW5pcXVlSUQoKS5zdWJzdHIoMCwgMTApfWA7XG59XG5cbmZ1bmN0aW9uKiBvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZShkaXJlY3RMaW5lKSB7XG4gIGNvbnN0IGNvbm5lY3Rpb25TdGF0dXNRdWV1ZSA9IGNyZWF0ZVByb21pc2VRdWV1ZSgpO1xuICBjb25zdCBjb25uZWN0aW9uU3RhdHVzU3Vic2NyaXB0aW9uID0gZGlyZWN0TGluZS5jb25uZWN0aW9uU3RhdHVzJC5zdWJzY3JpYmUoeyBuZXh0OiBjb25uZWN0aW9uU3RhdHVzUXVldWUucHVzaCB9KTtcblxuICB0cnkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0dXMgPSB5aWVsZCBjYWxsKGNvbm5lY3Rpb25TdGF0dXNRdWV1ZS5zaGlmdCk7XG5cbiAgICAgIHlpZWxkIHB1dCh1cGRhdGVDb25uZWN0aW9uU3RhdHVzKGNvbm5lY3Rpb25TdGF0dXMpKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY29ubmVjdGlvblN0YXR1c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG5cbi8vIFRPRE86IFtQMl0gV2Ugc2hvdWxkIG1vdmUgdGhpcyBjaGVjayBhbmQgcmVjdGlmaWNhdGlvbiB0byBEaXJlY3RMaW5lSlMuXG5mdW5jdGlvbiByZWN0aWZ5VXNlcklEKGRpcmVjdExpbmUsIHVzZXJJREZyb21BY3Rpb24pIHtcbiAgY29uc3QgeyB0b2tlbiB9ID0gZGlyZWN0TGluZTtcbiAgY29uc3QgeyB1c2VyOiB1c2VySURGcm9tVG9rZW4gfSA9IGRlY29kZSh0b2tlbikgfHwge307XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGZyb21BY3Rpb246IHVzZXJJREZyb21BY3Rpb24sXG4gICAgZnJvbVRva2VuOiB1c2VySURGcm9tVG9rZW5cbiAgfTtcblxuICBpZiAodXNlcklERnJvbVRva2VuKSB7XG4gICAgaWYgKHVzZXJJREZyb21BY3Rpb24gJiYgdXNlcklERnJvbUFjdGlvbiAhPT0gdXNlcklERnJvbVRva2VuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdXZWIgQ2hhdDogdXNlciBJRCBpcyBib3RoIHNwZWNpZmllZCBpbiB0aGUgRGlyZWN0IExpbmUgdG9rZW4gYW5kIHBhc3NlZCBpbiwgd2lsbCB1c2UgdGhlIHVzZXIgSUQgZnJvbSB0aGUgdG9rZW4uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXN1bHQuZmluYWwgPSB1c2VySURGcm9tVG9rZW47XG4gIH0gZWxzZSBpZiAodXNlcklERnJvbUFjdGlvbikge1xuICAgIGlmICh0eXBlb2YgdXNlcklERnJvbUFjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUud2FybignV2ViIENoYXQ6IHVzZXIgSUQgbXVzdCBiZSBhIHN0cmluZy4nKTtcblxuICAgICAgcmVzdWx0LmZpbmFsID0gcmFuZG9tVXNlcklEKCk7XG4gICAgfSBlbHNlIGlmICgvXmRsXy91LnRlc3QodXNlcklERnJvbUFjdGlvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1dlYiBDaGF0OiB1c2VyIElEIHByZWZpeGVkIHdpdGggXCJkbF9cIiBpcyByZXNlcnZlZCBhbmQgbXVzdCBiZSBlbWJlZGRlZCBpbnRvIHRoZSBEaXJlY3QgTGluZSB0b2tlbiB0byBwcmV2ZW50IGZvcmdlcnkuJ1xuICAgICAgKTtcblxuICAgICAgcmVzdWx0LmZpbmFsID0gcmFuZG9tVXNlcklEKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5maW5hbCA9IHVzZXJJREZyb21BY3Rpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5maW5hbCA9IHJhbmRvbVVzZXJJRCgpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gV2UgY291bGQgbWFrZSB0aGlzIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHNhZ2EgKGZ1bmN0aW9uIGdlbmVyYXRvcikgdG8gbWFrZSB0aGUgY29kZSBjbGVhbmVyLCBpZjpcbi8vIDEuIFdlIGZvdW5kIGEgd2F5IHRvIGNhbmNlbCBQcm9taXNlXG4vLyAyLiBzdWJzY3JpYmUoKSBhcmUgc2hhcmVkIGFtb25nc3QgYWxsIHN1YnNjcmlwdGlvbnMsIGUuZy4gdHVybiBPYnNlcnZhYmxlIGludG8gZXZlbnRzXG5mdW5jdGlvbiogY29ubmVjdFNhZ2EoZGlyZWN0TGluZSkge1xuICAvLyBEaXJlY3RMaW5lSlMgc3RhcnRzIHRoZSBjb25uZWN0aW9uIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IHN1YnNjcmliZXIgZm9yIGFjdGl2aXR5JCwgbm90IGNvbm5lY3Rpb25TdGF0dXMkXG4gIGNvbnN0IGFjdGl2aXR5U3Vic2NyaXB0aW9uID0gZGlyZWN0TGluZS5hY3Rpdml0eSQuc3Vic2NyaWJlKHsgbmV4dDogKCkgPT4gMCB9KTtcbiAgY29uc3QgdW5zdWJzY3JpYmVBY3Rpdml0eSA9IGFjdGl2aXR5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlLmJpbmQoYWN0aXZpdHlTdWJzY3JpcHRpb24pO1xuXG4gIHRyeSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXlsb2FkOiB7IGNvbm5lY3Rpb25TdGF0dXMgfVxuICAgICAgfSA9IHlpZWxkIHRha2UoVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTKTtcblxuICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0dXMgPT09IE9OTElORSkge1xuICAgICAgICAvLyBUT0RPOiBbUDJdIERpcmVjdExpbmVKUyBzaG91bGQga2lsbCB0aGUgY29ubmVjdGlvbiB3aGVuIHdlIHVuc3Vic2NyaWJlXG4gICAgICAgIC8vICAgICAgIEJ1dCBjdXJyZW50bHkgaW4gdjMsIERpcmVjdExpbmVKUyBkb2VzIG5vdCBoYXZlIHRoaXMgZnVuY3Rpb25hbGl0eVxuICAgICAgICAvLyAgICAgICBUaHVzLCB3ZSBuZWVkIHRvIGNhbGwgXCJlbmQoKVwiIGV4cGxpY2l0bHlcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcbiAgICAgICAgICBkaXJlY3RMaW5lLmVuZCgpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdHVzICE9PSBVTklOSVRJQUxJWkVEICYmIGNvbm5lY3Rpb25TdGF0dXMgIT09IENPTk5FQ1RJTkcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCwgRGlyZWN0TGluZUpTIHJldHVybmVkICR7Y29ubmVjdGlvblN0YXR1c30uYCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBXZSB3aWxsIHVuc3Vic2NyaWJlIGlmIHdlIGZhaWxlZCB0byBjb25uZWN0IG9yIGdvdCBjYW5jZWxsZWQgb25seS5cbiAgICAvLyBXZSBzaG91bGQgbm90IHVuc3Vic2NyaWJlIGluIGhhcHB5IGNhc2UsIGJlY2F1c2UgRGlyZWN0TGluZUpTIHNob3VsZCByZWx5aW5nIG9uIHRoZSBzdWJzY3JpcHRpb24gdG8gY29ubmVjdC9kaXNjb25uZWN0LlxuICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcblxuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoeWllbGQgY2FuY2VsbGVkKCkpIHtcbiAgICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29ubmVjdFNhZ2EoKSB7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXlsb2FkOiB7IGNvbm5lY3Rpb25TdGF0dXMgfVxuICAgIH0gPSB5aWVsZCB0YWtlKFVQREFURV9DT05ORUNUSU9OX1NUQVRVUyk7XG5cbiAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gT05MSU5FKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0dXMgIT09IENPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlY29ubmVjdC4gRGlyZWN0TGluZUpTIHJldHVybmVkICR7Y29ubmVjdGlvblN0YXR1c30uYCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgc2ltaWxhciB0byBiZWhhdmlvciBvZiByZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUsIGJ1dCB1c2luZyBzYWdhIGluc3RlYWQgb2YgUHJvbWlzZS5cbi8vIFdlIGd1YXJhbnRlZSBQRU5ESU5HIC0+IEZVTEZJTExJTkcgLT4gRlVMRklMTEVELCBvciBQRU5ESU5HIC0+IFJFSkVDVEVELiBUaGlzIHdpbGwgaGVscCB1cyBzaW1wbGlmeSBsb2dpYyBpbiBvdGhlciBwYXJ0IG9mIGNvZGUuXG4vLyBOb3RlIHRoYXQgYWZ0ZXIgdGhlIHNhZ2EgaXMgY2FuY2VsbGVkLCBzdWJzZXF1ZW50IGNhbGwgdG8gcHV0KCkgd2lsbCBiZSBpZ25vcmVkIHNpbGVudGx5LlxuZnVuY3Rpb24qIHJ1bkFzeW5jRWZmZWN0KHsgdHlwZSwgbWV0YSwgcGF5bG9hZCB9LCBjYWxsRWZmZWN0RmFjdG9yeSkge1xuICB0cnkge1xuICAgIHlpZWxkIGZvcmtQdXQoeyB0eXBlOiBgJHt0eXBlfV9QRU5ESU5HYCwgbWV0YSwgcGF5bG9hZCB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGNhbGxFZmZlY3RGYWN0b3J5KCk7XG5cbiAgICB5aWVsZCBmb3JrUHV0KHsgdHlwZTogYCR7dHlwZX1fRlVMRklMTElOR2AsIG1ldGEsIHBheWxvYWQgfSwgeyB0eXBlOiBgJHt0eXBlfV9GVUxGSUxMRURgLCBtZXRhLCBwYXlsb2FkIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAocGF5bG9hZCkge1xuICAgIHlpZWxkIGZvcmtQdXQoeyB0eXBlOiBgJHt0eXBlfV9SRUpFQ1RFRGAsIGVycm9yOiB0cnVlLCBtZXRhLCBwYXlsb2FkIH0pO1xuXG4gICAgdGhyb3cgcGF5bG9hZDtcbiAgfVxufVxuXG5mdW5jdGlvbiogdGFrZURpc2Nvbm5lY3RBc0Vycm9yKCkge1xuICB5aWVsZCB0YWtlKERJU0NPTk5FQ1QpO1xuXG4gIHRocm93IG5ldyBFcnJvcignZGlzY29ubmVjdGVkJyk7XG59XG5cbmZ1bmN0aW9uIHJ1bkFzeW5jRWZmZWN0VW50aWxEaXNjb25uZWN0KGJhc2VBY3Rpb24sIGNhbGxFZmZlY3RGYWN0b3J5KSB7XG4gIC8vIFdlIGNhbm5vdCB1c2Ugc2FnYSBjYW5jZWwoKSBoZXJlLCBiZWNhdXNlIGNhbmNlbGxpbmcgc2FnYSB3aWxsIHByb2hpYml0IHVzIGZyb20gc2VuZGluZyAqX1JFSkVDVEVELlxuICAvLyBXaXRob3V0IFJFSkVDVEVELCBpdCBpbXBhY3RzIG91ciBhc3N1bXB0aW9ucyBhcm91bmQgUEVORElORy9GVUxGSUxMRUQvUkVKRUNURUQuXG4gIHJldHVybiBydW5Bc3luY0VmZmVjdChiYXNlQWN0aW9uLCBmdW5jdGlvbiogcnVuVW50aWxEaXNjb25uZWN0KCkge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSB5aWVsZCByYWNlKHtcbiAgICAgIF86IHRha2VEaXNjb25uZWN0QXNFcnJvcigpLFxuICAgICAgcmVzdWx0OiBjYWxsRWZmZWN0RmFjdG9yeSgpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qICgpIHtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBheWxvYWQ6IHsgZGlyZWN0TGluZSwgdXNlcklEOiB1c2VySURGcm9tQWN0aW9uLCB1c2VybmFtZSB9XG4gICAgfSA9IHlpZWxkIHRha2UoQ09OTkVDVCk7XG5cbiAgICBjb25zdCB1cGRhdGVDb25uZWN0aW9uU3RhdHVzVGFzayA9IHlpZWxkIGZvcmsob2JzZXJ2ZUFuZFB1dENvbm5lY3Rpb25TdGF0dXNVcGRhdGUsIGRpcmVjdExpbmUpO1xuICAgIGNvbnN0IHJlY3RpZmllZFVzZXJJRCA9IHJlY3RpZnlVc2VySUQoZGlyZWN0TGluZSwgdXNlcklERnJvbUFjdGlvbik7XG5cbiAgICAvLyBUT0RPOiBbUDJdIENoZWNrcyBpZiB0aGlzIGF0dGFjaGVkIHN1YnRhc2sgd2lsbCBnZXQga2lsbGVkIGlmIHRoZSBwYXJlbnQgdGFzayBpcyBjb21wbGV0ZSAocGVhY2VmdWxseSksIGVycm9yZWQgb3V0LCBvciBjYW5jZWxsZWQuXG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgIHVzZXJJRDogcmVjdGlmaWVkVXNlcklELmZpbmFsLFxuICAgICAgdXNlcm5hbWVcbiAgICB9O1xuXG4gICAgLy8gU2VuZCB1c2VyIElEIHRvIERpcmVjdExpbmVKUyBpZiBpdCB3YXMgc3BlY2lmaWVkIGZyb20gcHJvcHMgb2YgPEFQSS5Db21wb3Nlcj4uXG4gICAgLy8gSG93ZXZlciwgRGlyZWN0TGluZUpTIG1heSBzdGlsbCBwcmVmZXIgdGhlIHVzZXIgSUQgZnJvbSB0b2tlbiBpZiBpdCBpcyBidXJudCBpbnRvIHRoZSB0b2tlbi5cbiAgICAvLyBUbyBwcmV2ZW50IERpcmVjdExpbmVKUyBnaXZpbmcgZmFsc2Ugd2FybmluZ3MsIHdlIHdpbGwgb25seSBjYWxsIHNldFVzZXJJZCgpIGlmIGl0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSB0b2tlbi5cbiAgICBkaXJlY3RMaW5lLnNldFVzZXJJZCAmJiByZWN0aWZpZWRVc2VySUQuZnJvbVRva2VuICE9PSBtZXRhLnVzZXJJRCAmJiBkaXJlY3RMaW5lLnNldFVzZXJJZChtZXRhLnVzZXJJRCk7XG5cbiAgICBsZXQgZGlzY29ubmVjdE1ldGE7XG5cbiAgICAvLyBXZSB3aWxsIGRpc3BhdGNoIENPTk5FQ1RfUEVORElORywgd2FpdCBmb3IgY29ubmVjdCBjb21wbGV0ZWQsIGVycm9yZWQsIG9yIGNhbmNlbGxlZCAodGhydSBkaXNjb25uZWN0KS5cbiAgICAvLyBUaGVuIGRpc3BhdGNoIENPTk5FQ1RfRlVMRklMTEVEL0NPTk5FQ1RfUkVKRUNURUQgYXMgbmVlZGVkLlxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmREaXJlY3RMaW5lID0geWllbGQgcnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QoXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBDT05ORUNULFxuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgcGF5bG9hZDogeyBkaXJlY3RMaW5lIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gY2FsbChjb25uZWN0U2FnYSwgZGlyZWN0TGluZSlcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAvLyBXZSBhcmUgd2FpdGluZyBmb3IgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlIG9yIGRpc2Nvbm5lY3QgYWN0aW9uLlxuICAgICAgICAgIGNvbnN0IHsgdXBkYXRlQ29ubmVjdGlvblN0YXR1c0FjdGlvbjogeyBwYXlsb2FkOiB7IGNvbm5lY3Rpb25TdGF0dXMgfSA9IHt9IH0gPSB7fSB9ID0geWllbGQgcmFjZSh7XG4gICAgICAgICAgICBfOiB0YWtlKERJU0NPTk5FQ1QpLFxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXR1c0FjdGlvbjogdGFrZShVUERBVEVfQ09OTkVDVElPTl9TVEFUVVMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgZGlzY29ubmVjdCBhY3Rpb24sIGNvbm5lY3Rpb25TdGF0dXMgd2lsbCBub3QgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzID09PSBDT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAvLyBJZiBEaXJlY3RMaW5lSlMgY2hhbmdlZCBjb25uZWN0aW9uU3RhdHVzIHRvIENPTk5FQ1RJTkcsIHdlIHdpbGwgdHJlYXQgaXQgYXMgcmVjb25uZWN0IHN0YXR1cy5cbiAgICAgICAgICAgIHlpZWxkIHJ1bkFzeW5jRWZmZWN0VW50aWxEaXNjb25uZWN0KFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogUkVDT05ORUNULFxuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogeyBkaXJlY3RMaW5lIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKCkgPT4gY2FsbChyZWNvbm5lY3RTYWdhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0dXMgIT09IE9OTElORSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uU3RhdHVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGtpbGwgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBEaXJlY3RMaW5lSlMgd2FudCB0byBjbG9zZSBpdC5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VkIHRvICR7Y29ubmVjdGlvblN0YXR1c31gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNvbWVvbmUgZGlzcGF0Y2hlZCBkaXNjb25uZWN0IGFjdGlvbi5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBlbmREaXJlY3RMaW5lKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRpc2Nvbm5lY3RNZXRhID0geyBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB5aWVsZCBjYW5jZWwodXBkYXRlQ29ubmVjdGlvblN0YXR1c1Rhc2spO1xuXG4gICAgICAvLyBFdmVuIGlmIHRoZSBjb25uZWN0aW9uIGlzIGludGVycnVwdGVkLCB3ZSB3aWxsIHN0aWxsIGVtaXQgRElTQ09OTkVDVF9QRU5ESU5HLlxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2VzIGhhbmRsaW5nIGxvZ2ljIGVhc2llci4gSWYgQ09OTkVDVF9GVUxGSUxMRUQsIHdlIGd1YXJhbnRlZSBESVNDT05ORUNUX1BFTkRJTkcuXG4gICAgICB5aWVsZCBmb3JrUHV0KFxuICAgICAgICB7IHR5cGU6IERJU0NPTk5FQ1RfUEVORElORywgbWV0YTogZGlzY29ubmVjdE1ldGEsIHBheWxvYWQ6IHsgZGlyZWN0TGluZSB9IH0sXG4gICAgICAgIHsgdHlwZTogRElTQ09OTkVDVF9GVUxGSUxMRUQsIG1ldGE6IGRpc2Nvbm5lY3RNZXRhLCBwYXlsb2FkOiB7IGRpcmVjdExpbmUgfSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl19